---
title: "Modelaje ACA"
author: "William A. Gutierrez V."
date: "2025-07-01"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    theme: flatly
    highlight: zenburn
    code_folding: hide
    df_print: paged
    fig_width: 14
    fig_height: 10
    code_download: true
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## **Exploraci칩n preliminar de los datos**

En esta secci칩n, realizamos una exploraci칩n preliminar de los datos para entender la estructura y el contenido del conjunto de datos. Esto incluye la carga de las librer칤as necesarias, la lectura del archivo Excel que contiene los datos de los proyectos, y la creaci칩n de variables dummy para las tipolog칤as de proyectos y gobernaci칩n.
```{r}
# Cargar las librer칤as
library(readxl)   
library(dplyr)    
library(writexl)
library(vegan)
library(permute)
library(fastDummies)
library(ggplot2)
library(scales)
library(AER)
library(sf)
library(tidyr)
library(viridis)
library(knitr)
library(data.table)
library(carData)
library(stringr)
library(purrr)
library(cowplot)
library(GGally)
library(viridis)
library(ggspatial)
library(ggpubr)
library(nortest)
library(gridExtra)
library(tibble)
library(reshape2)
library(kableExtra)
library(formattable)
library(DT)
library(corrplot)
library(ggridges)
library(treemapify)
library(RColorBrewer)
library(ggrepel)
library(igraph)
library(ggraph)
library(ggdendro)
library(patchwork)
library(pheatmap)
library(grid)
library(cluster)  
library(mclust)
library(DT)    
library(factoextra)
library(car)
library(MASS)
library(broom)
library(ggeffects)
library(margins)
library(tmap)
library(sp)
library(conflicted)
library(biscale)
```

## **Desarrollamos las estimaciones de las tipolog칤as de proyectos**

```{r, clasificacion de las tipologias}

knitr::opts_chunk$set(echo = TRUE)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")

## -------------**Creaci칩n de variables dummy y resumen por comuna**---------------------##
df_raw <- read_excel ("C:/Users/william/Desktop/monografia aca merida/datos/ACA Modelaje R Final.xlsx", 
    sheet = "Resumen") %>%
  mutate(ID_COMUNA = paste0(COD_UBIGEO, "-", COD_CC))

# Crear dummies desde las variables cualitativas
df_dummies <- df_raw %>%
  dummy_cols(
    select_columns = c(
      "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG",
      "CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION",
      "CLASIFICACION_DEL_PROYECTO"
    ),
    remove_first_dummy = FALSE
  )

# ---------------------Primera tabla - Variables originales (primeros 10 registros)---------------------
tabla1 <- df_raw %>%
  select(
    `Nudo Cr칤ticos por Tipolog칤a CFG` = CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
    `Nudos Cr칤ticos por Tipolog칤a de Gobierno` = CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
    `COD UBIGEO` = COD_UBIGEO,
    `COD CC` = COD_CC,
    COMUNA,
    `ID COMUNA` = ID_COMUNA
  ) %>%
  head(10)

kable(tabla1, caption = "Tabla 1. Primeros 10 registros de datos originales") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), font_size = 10) %>%
  footnote(general = "Nota. ID_COMUNA = Identificador 칰nico de comuna y combinaci칩n del c칩digo UBIGEO y c칩digo SITUR de cada comuna; COD_UBIGEO = C칩digo de ubicaci칩n geogr치fica a nivel nacional y M칠rida.",
           general_title = "")

#------------------------Segunda tabla - Variables importantes (primeros 10 registros)--------------------
tabla2 <- df_raw %>%
  select(
    n_proyectos,
    PLAZOS,
    CLASIFICACION_DEL_PROYECTO,
    TIPOLOGIA_CFG_NUM,
    GOBERNACION_NUM,
    RATIO_ACA_PROYECTO_CULMINADO,
    Clasificacion_Actores_institucionales
  ) %>%
  head(10)

kable(tabla2, caption = "Tabla 2. Primeros 10 registros de variables de an치lisis principales") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), font_size = 10)
```

## **An치lisis de tendencia central y de dispersi칩n de las variables originales**

```{r}
#-------------------- An치lisis de tendencia central y dispersi칩n---------------
analisis_tendencia <- df_raw %>%
  select(n_proyectos, PLAZOS,CLASIFICACION_DEL_PROYECTO, TIPOLOGIA_CFG_NUM, GOBERNACION_NUM, 
         RATIO_ACA_PROYECTO_CULMINADO, Clasificacion_Actores_institucionales) %>%
  psych::describe() %>%
  rownames_to_column("Variable") %>%
  select(Variable, n, mean, sd, min, max, median, skew, kurtosis)

kable(analisis_tendencia, caption = "Tabla 3. Medidas de tendencia central y dispersi칩n") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), font_size = 10)

# An치lisis de frecuencias para variables categ칩ricas n_proyectos
frecuencias_n_proyectos <- df_raw %>%
  count(n_proyectos) %>%
  mutate(Porcentaje = round(n / sum(n) * 100, 2)) %>%
  rename(Frecuencia = n, Categor칤a = n_proyectos)
kable(frecuencias_n_proyectos, caption = "Distribuci칩n de frecuencias para la variable n_proyectos") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# An치lisis de frecuencias para variables categ칩ricas Clasificaci칩n del proyecto

frecuencias_clasificacion_proyecto <- df_raw %>%
  count(CLASIFICACION_DEL_PROYECTO) %>%
  mutate(Porcentaje = round(n / sum(n) * 100, 2)) %>%
  rename(Frecuencia = n, Categor칤a = CLASIFICACION_DEL_PROYECTO)
kable(frecuencias_clasificacion_proyecto, caption = "Distribuci칩n de frecuencias para la variable CLASIFICACION_DEL_PROYECTO") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
  

# An치lisis de frecuencias para variables categ칩ricas Plazos
frecuencias_plazos <- df_raw %>%
  count(PLAZOS) %>%
  mutate(Porcentaje = round(n / sum(n) * 100, 2)) %>%
  rename(Frecuencia = n, Categor칤a = PLAZOS)

kable(frecuencias_plazos, caption = "Distribuci칩n de frecuencias para la variable PLAZOS") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# An치lisis de RATIO_ACA_PROYECTO_CULMINADO
frecuencias_ratio <- df_raw %>%
  count(RATIO_ACA_PROYECTO_CULMINADO) %>%
  mutate(Porcentaje = round(n / sum(n) * 100, 2)) %>%
  rename(Frecuencia = n, Categor칤a = RATIO_ACA_PROYECTO_CULMINADO)

kable(frecuencias_ratio, caption = "Distribuci칩n de frecuencias para la variable RATIO_ACA_PROYECTO_CULMINADO") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# An치lisis de actores institucionales
frecuencias_actores <- df_raw %>%
  count(Clasificacion_Actores_institucionales) %>%
  mutate(Porcentaje = round(n / sum(n) * 100, 2)) %>%
  rename(Frecuencia = n, Categor칤a = Clasificacion_Actores_institucionales)

kable(frecuencias_actores, caption = "Distribuci칩n de frecuencias para la variable Clasificacion_Actores_institucionales") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

##--------------------------Trafico de frecuencias---------------------------

# Combinar todos los dataframes de frecuencias en uno solo
plot_data <- bind_rows(
  frecuencias_n_proyectos %>% mutate(Variable = "N칰mero de Consultas (n_proyectos)"),
  frecuencias_clasificacion_proyecto %>% mutate(Variable = "Estado del Proyecto"),
  frecuencias_ratio %>% mutate(Variable = "Ratio de Efectividad"),
  frecuencias_plazos %>% mutate(Variable = "Plazo de Ejecuci칩n (PLAZOS)"),
  frecuencias_actores %>% mutate(Variable = "Actor Institucional Principal")
) %>%
  mutate(Categor칤a = as.factor(Categor칤a))

# Definir etiquetas descriptivas para cada categor칤a
plot_data <- plot_data %>%
  mutate(
    Etiqueta_Categoria = case_when(
      Variable == "Estado del Proyecto" ~ case_when(
        Categor칤a == 1 ~ "1 - No Considerado",
        Categor칤a == 2 ~ "2 - No Culminado",
        Categor칤a == 3 ~ "3 - En Ejecuci칩n",
        Categor칤a == 4 ~ "4 - Culminado"
      ),
      Variable == "Ratio de Efectividad" ~ case_when(
        Categor칤a == 1 ~ "1 - Muy Baja",
        Categor칤a == 2 ~ "2 - Baja",
        Categor칤a == 3 ~ "3 - Media",
        Categor칤a == 4 ~ "4 - Alta"
      ),
      Variable == "Plazo de Ejecuci칩n (PLAZOS)" ~ case_when(
        Categor칤a == 0 ~ "0 - Sin Dato",
        Categor칤a == 1 ~ "1 - Corto Plazo",
        Categor칤a == 2 ~ "2 - Mediano Plazo"
      ),
      Variable == "Actor Institucional Principal" ~ case_when(
        Categor칤a == 1 ~ "1 - Ministerio",
        Categor칤a == 2 ~ "2 - Gob. Nac/Est.",
        Categor칤a == 3 ~ "3 - Mun./Comunal",
        Categor칤a == 4 ~ "4 - Privado"
      ),
      Variable == "N칰mero de Consultas (n_proyectos)" ~ as.character(Categor칤a),
      TRUE ~ as.character(Categor칤a)
    )
  )

# Calcular el l칤mite superior del eje Y para asegurar que las etiquetas encajen
y_max <- max(plot_data$Frecuencia) * 1.1

# Crear el gr치fico de barras con facetas mejorado
ggplot(plot_data, aes(x = Etiqueta_Categoria, y = Frecuencia, fill = Etiqueta_Categoria)) +
  geom_col(show.legend = FALSE) +  
  geom_text(aes(label = Frecuencia), vjust = -0.5, size = 3.5) +  
  facet_wrap(~ Variable, scales = "free_x", ncol = 5) + 
  scale_fill_viridis_d() + 
  labs(
    title = "Distribuci칩n de Frecuencias de Variables Clave",
    x = "Categor칤as",
    y = "Frecuencia (N칰mero de Proyectos)",
    caption = "Elaboraci칩n Propia - William Gutierrez"  
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),  
    strip.text = element_text(face = "bold", size = 10), 
    plot.title = element_text(hjust = 0.5, face = "bold"),  
    plot.caption = element_text(hjust = 1, size = 9, face = "italic")  
  ) +
  ylim(0, y_max)  
```


## **Frecuencia global por cada tipolog칤a, 쯤u칠 problema es el m치s com칰n?**

Para establecer cu치les son los nudos cr칤ticos m치s recurrentes en todo el Estado M칠rida, primero calculamos la frecuencia absoluta y relativa de cada tipolog칤a CFG y de gobernaci칩n. Esto nos permite identificar las 치reas de mayor concentraci칩n de problemas y priorizar las l칤neas de an치lisis posteriores.

```{r, frecuencia global CFG}

##----------------------------Resumen CFG por Comuna---------------------------
cfg_cols <- df_dummies %>% 
  select(starts_with("CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_")) %>% 
  names()

df_cfg_summary <- df_dummies %>%
  group_by(ID_COMUNA) %>%
  summarise(
    n_proyectos = n(),
    across(all_of(cfg_cols), list(
      count = ~ sum(.x, na.rm = TRUE),
      pct = ~ sum(.x, na.rm = TRUE) / n() * 100
    ))
  ) %>%
  ungroup()

##-----------------------Resumen de Gobernaci칩n por comuna----------------------
gob_cols <- df_dummies %>% 
  select(starts_with("CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_")) %>% 
  names()

df_gob_summary <- df_dummies %>%
  group_by(ID_COMUNA) %>%
  summarise(
    n_proyectos = n(),
    across(all_of(gob_cols), list(
      count = ~ sum(.x, na.rm = TRUE),
      pct = ~ sum(.x, na.rm = TRUE) / n() * 100
    ))
  ) %>%
  ungroup()

##------------------------An치lisis de frecuencias-------------------------------

# Funci칩n mejorada para an치lisis completo
analizar_frecuencia <- function(data, var, fill_color, line_color, titulo, tipo = "proyectos") {
  # Determinar nombre de etiqueta seg칰n tipo
  y_label <- ifelse(tipo == "proyectos", "N칰mero de proyectos", "N칰mero de comunas")
  
  # Frecuencias globales
  freq <- data %>%
    count({{var}}, name = "n") %>%
    arrange(desc(n)) %>%
    mutate(
      pct = n / sum(n) * 100,
      cum_pct = cumsum(pct),
      etiqueta = paste0(n, "\n(", round(pct, 1), "%)")
    )
  
  # Gr치fico combinado
  plot <- ggplot(freq, 
         aes(x = reorder({{var}}, n), y = n)) +
    geom_col(fill = fill_color, alpha = 0.8) +
    geom_text(aes(label = etiqueta), 
              hjust = -0.1, size = 3.5, color = "black", lineheight = 0.8) +
    geom_line(aes(y = cum_pct * max(n) / 100), 
              group = 1, color = line_color, size = 0.8) +
    geom_point(aes(y = cum_pct * max(n) / 100), 
               color = line_color, size = 2) +
    scale_y_continuous(
      name = y_label,
      sec.axis = sec_axis(~ . * 100 / max(freq$n), 
                         name = "Porcentaje acumulado (%)",
                         labels = scales::percent_format(scale = 1))
    ) +
    coord_flip() +
    labs(
      title = titulo,
      subtitle = "Barras: frecuencia absoluta | Texto: conteo y % individual | L칤nea: % acumulado",
      x = NULL
    ) +
    theme_minimal(base_size = 12) +
    expand_limits(y = max(freq$n) * 1.15)
  
  return(list(freq = freq, plot = plot))
}

# Funci칩n mejorada para frecuencia por comuna
analizar_frecuencia_comuna <- function(data, var, fill_color, line_color, titulo) {
  freq_comuna <- data %>%
    distinct(ID_COMUNA, {{var}}) %>%  
    count({{var}}, name = "n_comunas") %>%
    arrange(desc(n_comunas)) %>%
    mutate(
      pct_comunas = n_comunas / sum(n_comunas) * 100,
      cum_pct = cumsum(pct_comunas),
      etiqueta = paste0(n_comunas, "\n(", round(pct_comunas, 1), "%)")
    )
  
  # Gr치fico combinado
  plot <- ggplot(freq_comuna, 
         aes(x = reorder({{var}}, n_comunas), y = n_comunas)) +
    geom_col(fill = fill_color, alpha = 0.8) +
    geom_text(aes(label = etiqueta), 
              hjust = -0.1, size = 3.5, color = "black", lineheight = 0.8) +
    geom_line(aes(y = cum_pct * max(n_comunas) / 100),
              group = 1, color = line_color, size = 0.8) +
    geom_point(aes(y = cum_pct * max(n_comunas) / 100),
               color = line_color, size = 2) +
    scale_y_continuous(
      name = "N칰mero de comunas",
      sec.axis = sec_axis(~ . * 100 / max(freq_comuna$n_comunas),
                         name = "Porcentaje acumulado (%)",
                         labels = scales::percent_format(scale = 1))
    ) +
    coord_flip() +
    expand_limits(y = max(freq_comuna$n_comunas) * 1.15) +
    labs(
      title = titulo,
      subtitle = "Barras: frecuencia absoluta | Texto: conteo y % de comunas | L칤nea: % acumulado",
      x = NULL
    ) +
    theme_minimal(base_size = 12)
  
  return(list(freq_comuna = freq_comuna, plot = plot))
}
## ----------------------------An치lisis para CFG--------------------------------

# Conteo y proporciones globales por Tipologia CFG

cfg_global_proyectos <- analizar_frecuencia(
  df_dummies,
  CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
  "darkblue", "gold",
  "Frecuencia global de tipolog칤as CFG (Proyectos)"
)
cfg_global_comunas <- analizar_frecuencia_comuna(
  df_dummies,
  CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
  "darkblue", "gold",
  "Frecuencia de tipolog칤as CFG por comuna"
)
# Tablas de estad칤sticas descriptivas b치sicas de frecuencias para CFG
print(cfg_global_proyectos$freq)

##----------------------------Mostrar resultados-------------------------------------
# Conteo y proporciones globales sobre la variable original
freq_cfg <- df_dummies %>%
  count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "n") %>%
  arrange(desc(n)) %>%
  mutate(
    pct     = n / sum(n) * 100,
    cum_pct = cumsum(pct)
  )
#-------------------------Top 10 barras simples--------------------------------
freq_cfg %>%
  slice(1:10) %>%
  ggplot(aes(
    x = reorder(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, n),
    y = n
  )) +
    geom_col(fill = "darkblue") +
    coord_flip() +
    labs(
      title = "Top 10 tipolog칤as CFG m치s frecuentes",
      x     = "Tipolog칤a CFG",
      y     = "N칰mero de proyectos"
    ) +
    theme_minimal()

##--------------------Grafico de frecuencias de tipolog칤as CFG------------------
print(cfg_global_proyectos$plot)

#----------------------------------Tablas de estad칤sticas descriptivas b치sicas de frecuencias para CFG para las comunas-----------------------------------
print(cfg_global_comunas$freq_comuna)

#--------Frecuencia absoluta y relativa de comunas por tipolog칤a CFG---------
freq_cfg_comuna <- df_dummies %>%
  distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG) %>%
  count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "n_comunas") %>%
  arrange(desc(n_comunas)) %>%
  mutate(
    pct_comunas = n_comunas / sum(n_comunas) * 100,
    cum_pct     = cumsum(pct_comunas)
  )

#---------------------------------Top 10 comunas--------------------------------
freq_cfg_comuna %>%
  slice(1:10) %>%
  ggplot(aes(
    x = reorder(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, n_comunas),
    y = n_comunas
  )) +
    geom_col(fill = "darkblue") +
    coord_flip() +
    labs(
      title = "Top 10 tipolog칤as CFG por n칰mero de comunas",
      x     = "Tipolog칤a CFG",
      y     = "N칰mero de comunas"
    ) +
    theme_minimal()
##----------------Grafico de frecuencias de tipolog칤as CFG--------------------
print(cfg_global_comunas$plot)

# ==============================================================================
#  TABLA COMPLETA DE FRECUENCIAS CFG POR PROYECTOS
# ==============================================================================

crear_tabla_cfg_proyectos <- function(data) {
  
  # Calcular frecuencias
  tabla_cfg <- data %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "n_proyectos") %>%
    arrange(desc(n_proyectos)) %>%
    mutate(
      porcentaje = round(n_proyectos / sum(n_proyectos) * 100, 2),
      pct_acumulado = round(cumsum(porcentaje), 2),
      ranking = row_number()
    ) %>%
    rename(
      "Ranking" = ranking,
      "Tipolog칤a CFG" = CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
      "N춿 Proyectos" = n_proyectos,
      "Porcentaje (%)" = porcentaje,
      "% Acumulado" = pct_acumulado
    )
  
  # Crear tabla formateada con kableExtra
  tabla_final <- tabla_cfg %>%
    kable(
      caption = "Tabla 4.1: Distribuci칩n de Frecuencias de Tipolog칤as CFG por N칰mero de Proyectos",
      align = c("c", "l", "c", "c", "c"),
      format = "html"
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 12
    ) %>%
    column_spec(1, bold = TRUE, color = "white", background = "#2c3e50") %>%
    column_spec(2, width = "20em") %>%
    column_spec(3:5, width = "8em") %>%
    row_spec(1:4, background = "#e8f4fd") %>%  # Resaltar top 4
    add_header_above(c(" " = 2, "Frecuencias Absolutas y Relativas" = 3)) %>%
    footnote(
      general = c(
        "Fuente: Elaboraci칩n propia basada en datos del Estado M칠rida 2019-2025",
        "Nota: Las primeras 4 tipolog칤as concentran el 62.6% de todos los nudos cr칤ticos"
      ),
      general_title = "",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = tabla_cfg, tabla = tabla_final))
}

# ==============================================================================
#  TABLA COMPLETA DE FRECUENCIAS CFG POR COMUNAS
# ==============================================================================

crear_tabla_cfg_comunas <- function(data) {
  
  # Calcular frecuencias por comuna (sin repetir comunas)
  tabla_cfg_comunas <- data %>%
    distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG) %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "n_comunas") %>%
    arrange(desc(n_comunas)) %>%
    mutate(
      porcentaje = round(n_comunas / sum(n_comunas) * 100, 2),
      pct_acumulado = round(cumsum(porcentaje), 2),
      ranking = row_number()
    ) %>%
    rename(
      "Ranking" = ranking,
      "Tipolog칤a CFG" = CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
      "N춿 Comunas" = n_comunas,
      "Porcentaje (%)" = porcentaje,
      "% Acumulado" = pct_acumulado
    )
  
  # Crear tabla formateada
  tabla_final <- tabla_cfg_comunas %>%
    kable(
      caption = "Tabla 4.2: Distribuci칩n de Frecuencias de Tipolog칤as CFG por N칰mero de Comunas Afectadas",
      align = c("c", "l", "c", "c", "c"),
      format = "html"
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 12
    ) %>%
    column_spec(1, bold = TRUE, color = "white", background = "#2c3e50") %>%
    column_spec(2, width = "20em") %>%
    column_spec(3:5, width = "8em") %>%
    row_spec(1:4, background = "#e8f4fd") %>%  # Resaltar top 4
    add_header_above(c(" " = 2, "Distribuci칩n Territorial" = 3)) %>%
    footnote(
      general = c(
        "Fuente: Elaboraci칩n propia basada en datos del Estado M칠rida 2019-2025",
        "Nota: Una comuna puede tener m칰ltiples tipolog칤as, pero se cuenta una sola vez por tipolog칤a"
      ),
      general_title = "",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = tabla_cfg_comunas, tabla = tabla_final))
}

# ==============================================================================
# TABLA COMPARATIVA CFG: PROYECTOS VS COMUNAS
# ==============================================================================

crear_tabla_comparativa_cfg <- function(data) {
  
  # Datos por proyectos
  cfg_proyectos <- data %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "n_proyectos") %>%
    mutate(pct_proyectos = round(n_proyectos / sum(n_proyectos) * 100, 2))
  
  # Datos por comunas
  cfg_comunas <- data %>%
    distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG) %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "n_comunas") %>%
    mutate(pct_comunas = round(n_comunas / sum(n_comunas) * 100, 2))
  
  # Unir ambas tablas
  tabla_comparativa <- cfg_proyectos %>%
    inner_join(cfg_comunas, by = "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG") %>%
    arrange(desc(n_proyectos)) %>%
    mutate(
      ranking = row_number(),
      intensidad = round(n_proyectos / n_comunas, 2)  # Proyectos por comuna promedio
    ) %>%
    select(
      ranking,
      CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
      n_proyectos, pct_proyectos,
      n_comunas, pct_comunas,
      intensidad
    ) %>%
    rename(
      "Rank" = ranking,
      "Tipolog칤a CFG" = CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
      "N춿 Proy." = n_proyectos,
      "% Proy." = pct_proyectos,
      "N춿 Com." = n_comunas,
      "% Com." = pct_comunas,
      "Intensidad" = intensidad
    )
  
  # Crear tabla formateada
  tabla_final <- tabla_comparativa %>%
    kable(
      caption = "Tabla 4.3: An치lisis Comparativo CFG - Proyectos vs Comunas Afectadas",
      align = c("c", "l", rep("c", 5)),
      format = "html",
      digits = 2
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 11
    ) %>%
    column_spec(1, bold = TRUE, color = "white", background = "#2c3e50", width = "3em") %>%
    column_spec(2, width = "15em") %>%
    column_spec(3:7, width = "6em") %>%
    add_header_above(c(" " = 2, "Por Proyectos" = 2, "Por Comunas" = 2, "Indicador" = 1)) %>%
    row_spec(1:3, background = "#ffe6e6") %>%  # Top 3 en rojo suave
    row_spec(4:7, background = "#fff2e6") %>%  # Siguientes 4 en naranja suave
    footnote(
      general = c(
        "Fuente: Elaboraci칩n propia basada en datos del Estado M칠rida 2019-2025",
        "Intensidad = N춿 Proyectos / N춿 Comunas (promedio de proyectos por comuna por tipolog칤a)"
      ),
      general_title = "",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = tabla_comparativa, tabla = tabla_final))
}

# ==============================================================================
#  TABLA RESUMEN EJECUTIVO CFG (TOP 10)
# ==============================================================================

crear_tabla_resumen_cfg <- function(data) {
  
  # Calcular estad칤sticas resumidas
  total_proyectos <- nrow(data)
  total_comunas <- n_distinct(data$ID_COMUNA)
  
  resumen_cfg <- data %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "proyectos") %>%
    arrange(desc(proyectos)) %>%
    slice(1:10) %>%  # Solo top 10
    mutate(
      pct_proyectos = round(proyectos / total_proyectos * 100, 1),
      pct_acum = round(cumsum(pct_proyectos), 1)
    ) %>%
    # Agregar datos de comunas
    left_join(
      data %>%
        distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG) %>%
        count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, name = "comunas"),
      by = "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG"
    ) %>%
    mutate(
      pct_comunas = round(comunas / total_comunas * 100, 1),
      posicion = row_number(),
      categoria = case_when(
        posicion <= 3 ~ "游댮 Cr칤tico",
        posicion <= 7 ~ "游리 Alto",
        TRUE ~ "游릭 Medio"
      )
    ) %>%
    select(
      posicion, categoria,
      CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
      proyectos, pct_proyectos, pct_acum,
      comunas, pct_comunas
    ) %>%
    rename(
      "Pos." = posicion,
      "Nivel" = categoria,
      "Tipolog칤a CFG" = CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG,
      "Proy." = proyectos,
      "%" = pct_proyectos,
      "% Acum." = pct_acum,
      "Com." = comunas,
      "% Com." = pct_comunas
    )
  
  # Crear tabla formateada
  tabla_final <- resumen_cfg %>%
    kable(
      caption = "Tabla 4.4: Resumen Ejecutivo - Top 10 Tipolog칤as CFG M치s Cr칤ticas",
      align = c("c", "c", "l", rep("c", 5)),
      format = "html"
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 11
    ) %>%
    column_spec(1, bold = TRUE, width = "3em") %>%
    column_spec(2, width = "8em") %>%
    column_spec(3, width = "15em") %>%
    column_spec(4:8, width = "5em") %>%
    add_header_above(c(" " = 3, "An치lisis por Proyectos" = 3, "Por Comunas" = 2)) %>%
    footnote(
      general = paste0(
        "Total analizado: ", total_proyectos, " proyectos en ", total_comunas, " comunas. ",
        "El Top 10 concentra el ", round(sum(resumen_cfg$`%`), 1), "% de todos los nudos cr칤ticos."
      ),
      general_title = "Nota:",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = resumen_cfg, tabla = tabla_final))
}
```

## **An치lisis de Tipolog칤as CFG: Tablas Descriptivas**

En esta secci칩n presentamos el an치lisis detallado de las tipolog칤as CFG mediante tablas descriptivas que permiten visualizar la distribuci칩n, frecuencia e impacto territorial de los nudos cr칤ticos identificados.

### **Tabla 4.1: Distribuci칩n de Frecuencias de Tipolog칤as CFG por N칰mero de Proyectos**

```{r tabla_4.1, echo=FALSE, warning=FALSE}
# Generar tabla de proyectos
tabla_proyectos <- crear_tabla_cfg_proyectos(df_dummies)
tabla_proyectos$tabla
```

*Nota: La tabla muestra la distribuci칩n absoluta y relativa de las tipolog칤as CFG seg칰n el n칰mero de proyectos asociados.*

### **Tabla 4.2: Distribuci칩n de Frecuencias de Tipolog칤as CFG por N칰mero de Comunas Afectadas**

```{r tabla_4.2, echo=FALSE, warning=FALSE}
# Generar tabla de comunas
tabla_comunas <- crear_tabla_cfg_comunas(df_dummies)
tabla_comunas$tabla
```

*Nota: Esta tabla representa la distribuci칩n territorial de las tipolog칤as, contabilizando cu치ntas comunas est치n afectadas por cada tipo de nudo cr칤tico.*

### **Tabla 4.3: An치lisis Comparativo CFG - Proyectos vs Comunas Afectadas**

```{r tabla_4.3, echo=FALSE, warning=FALSE}
# Generar tabla comparativa
tabla_comparativa <- crear_tabla_comparativa_cfg(df_dummies)
tabla_comparativa$tabla
```

*Nota: El indicador de intensidad (proyectos/comuna) permite identificar tipolog칤as con mayor concentraci칩n de problemas por territorio.*

### **Tabla 4.4: Resumen Ejecutivo - Top 10 Tipolog칤as CFG M치s Cr칤ticas**

```{r tabla_4.4, echo=FALSE, warning=FALSE}
# Generar tabla resumen ejecutivo
tabla_resumen <- crear_tabla_resumen_cfg(df_dummies)
tabla_resumen$tabla
```

*Nota: Clasificaci칩n por nivel de criticidad basado en la frecuencia de aparici칩n y distribuci칩n territorial.*

## **Exportaci칩n de Datos para An치lisis Adicional**

```{r exportar_tablas, echo=FALSE, warning=FALSE, eval=FALSE}
# Funci칩n para exportar tablas (opcional - solo si necesitas los archivos)
exportar_tablas_cfg <- function(tablas_objeto, ruta = "tablas_cfg/") {
  
  # Crear directorio si no existe
  if (!dir.exists(ruta)) dir.create(ruta, recursive = TRUE)
  
  # Exportar datos a CSV
  write.csv(tablas_objeto$proyectos$datos, 
            paste0(ruta, "cfg_por_proyectos.csv"), 
            row.names = FALSE)
  
  write.csv(tablas_objeto$comunas$datos, 
            paste0(ruta, "cfg_por_comunas.csv"), 
            row.names = FALSE)
  
  write.csv(tablas_objeto$comparativa$datos, 
            paste0(ruta, "cfg_comparativa.csv"), 
            row.names = FALSE)
  
  write.csv(tablas_objeto$resumen$datos, 
            paste0(ruta, "cfg_resumen_ejecutivo.csv"), 
            row.names = FALSE)
  
  cat("Tablas exportadas exitosamente a:", ruta, "\n")
}

# Crear objeto con todas las tablas (para exportaci칩n si es necesario)
tablas_cfg <- list(
  proyectos = tabla_proyectos,
  comunas = tabla_comunas, 
  comparativa = tabla_comparativa,
  resumen = tabla_resumen
)

# Para exportar, quitar eval=FALSE del chunk
# exportar_tablas_cfg(tablas_cfg)
```

## **Resumen Interpretativo del An치lisis CFG**

Los resultados muestran que las tipolog칤as CFG presentan distribuciones heterog칠neas tanto en frecuencia de proyectos como en alcance territorial. Las primeras cuatro tipolog칤as concentran m치s del 60% de los nudos cr칤ticos identificados, indicando 치reas prioritarias para la intervenci칩n.


Para complementar el an치lisis global, identificamos la tipolog칤a m치s frecuente en cada comuna. Esto nos permite ver si el patr칩n global se replica localmente o si existen particularidades territoriales.

Al igual que con las tipolog칤as CFG, calculamos la frecuencia absoluta y relativa de las categor칤as de gobernaci칩n. Esto nos permite identificar qu칠 actores institucionales son m치s relevantes en la gesti칩n de los proyectos.

##**Frecuencias de gobernaci칩n**

```{r, frecuencia global Gobernacion}
#----------------------------Resumen Gobernaci칩n por Comuna----------------------
## An치lisis para Gobernaci칩n ----
# Conteo y proporciones globales por Tipologia de Gobernaci칩n
freq_gob <- df_dummies %>%
  count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "n") %>%
  arrange(desc(n)) %>%
  mutate(pct = n / sum(n) * 100)


#  Gr치fico de barras (Top 10) de gobernaci칩n por proyectos
freq_gob %>%
  slice(1:10) %>%
  ggplot(aes(x = reorder(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, n),
             y = n)) +
    geom_col(fill = "darkred") +
    coord_flip() +
    labs(
      title = "Top 10 categor칤as de Gobernaci칩n m치s frecuentes",
      x     = "Categor칤a de Gobernaci칩n",
      y     = "N칰mero de proyectos"
    ) +
    theme_minimal()

# Frecuencia absoluta y relativa por comuna
freq_gob_comuna <- df_dummies %>%
  distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION) %>%  
  count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "n_comunas") %>%
  arrange(desc(n_comunas)) %>%
  mutate(
    pct_comunas = n_comunas / sum(n_comunas) * 100,
    cum_pct     = cumsum(pct_comunas)
  )


#----------------------------Gr치fico de top 10 por comuna---------------------------
freq_gob_comuna %>%
  slice(1:10) %>%
  ggplot(aes(
    x = reorder(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, n_comunas),
    y = n_comunas
  )) +
  geom_col(fill = "darkred") +
  coord_flip() +
  labs(
    title = "Top 10 categor칤as de Gobernaci칩n por n칰mero de comunas",
    x     = "Categor칤a de Gobernaci칩n",
    y     = "N칰mero de comunas"
  ) +
  theme_minimal()

# ------------------------Global - Proyectos-------------------------------------------
gob_global_proyectos <- analizar_frecuencia(
  df_raw,
  CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
  "darkred", "gold",
  "Frecuencia global de categor칤as de Gobernaci칩n (Proyectos)",
  "proyectos"
)

# -------------------------Global - Comunas--------------------------------------------
gob_global_comunas <- analizar_frecuencia_comuna(
  df_raw,
  CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
  "darkred", "gold",
  "Frecuencia de categor칤as de Gobernaci칩n por comuna"
)

#----------------------Grafico de frecuencias de categor칤as de Gobernaci칩n-------------
print(gob_global_proyectos$plot)

#----Grafico Frecuencia absoluta y relativa de comunas por categor칤a de Gobernaci칩n----
print(gob_global_comunas$plot)

# ==============================================================================
#  TABLA COMPLETA DE FRECUENCIAS GOBERNACI칍N POR PROYECTOS
# ==============================================================================
crear_tabla_gob_proyectos <- function(data) {
  
  # Calcular frecuencias
  tabla_gob <- data %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "n_proyectos") %>%
    arrange(desc(n_proyectos)) %>%
    mutate(
      porcentaje = round(n_proyectos / sum(n_proyectos) * 100, 2),
      pct_acumulado = round(cumsum(porcentaje), 2),
      ranking = row_number()
    ) %>%
    rename(
      "Ranking" = ranking,
      "Categor칤a Gobernaci칩n" = CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
      "N춿 Proyectos" = n_proyectos,
      "Porcentaje (%)" = porcentaje,
      "% Acumulado" = pct_acumulado
    )
  
  # Crear tabla formateada con kableExtra
  tabla_final <- tabla_gob %>%
    kable(
      caption = "Tabla 5.1: Distribuci칩n de Frecuencias de Categor칤as de Gobernaci칩n por N칰mero de Proyectos",
      align = c("c", "l", "c", "c", "c"),
      format = "html"
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 12
    ) %>%
    column_spec(1, bold = TRUE, color = "white", background = "#8B0000") %>%
    column_spec(2, width = "20em") %>%
    column_spec(3:5, width = "8em") %>%
    row_spec(1:4, background = "#ffebee") %>%  # Resaltar top 4
    add_header_above(c(" " = 2, "Frecuencias Absolutas y Relativas" = 3)) %>%
    footnote(
      general = c(
        "Fuente: Elaboraci칩n propia basada en datos del Estado M칠rida 2019-2025",
        "Nota: Las primeras 4 categor칤as concentran el 51.5% de todos los proyectos"
      ),
      general_title = "",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = tabla_gob, tabla = tabla_final))
}

# ==============================================================================
#  TABLA COMPLETA DE FRECUENCIAS GOBERNACI칍N POR COMUNAS
# ==============================================================================
crear_tabla_gob_comunas <- function(data) {
  
  # Calcular frecuencias por comuna (sin repetir comunas)
  tabla_gob_comunas <- data %>%
    distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION) %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "n_comunas") %>%
    arrange(desc(n_comunas)) %>%
    mutate(
      porcentaje = round(n_comunas / sum(n_comunas) * 100, 2),
      pct_acumulado = round(cumsum(porcentaje), 2),
      ranking = row_number()
    ) %>%
    rename(
      "Ranking" = ranking,
      "Categor칤a Gobernaci칩n" = CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
      "N춿 Comunas" = n_comunas,
      "Porcentaje (%)" = porcentaje,
      "% Acumulado" = pct_acumulado
    )
  
  # Crear tabla formateada
  tabla_final <- tabla_gob_comunas %>%
    kable(
      caption = "Tabla 5.2: Distribuci칩n de Frecuencias de Categor칤as de Gobernaci칩n por N칰mero de Comunas Afectadas",
      align = c("c", "l", "c", "c", "c"),
      format = "html"
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 12
    ) %>%
    column_spec(1, bold = TRUE, color = "white", background = "#8B0000") %>%
    column_spec(2, width = "20em") %>%
    column_spec(3:5, width = "8em") %>%
    row_spec(1:4, background = "#ffebee") %>%  # Resaltar top 4
    add_header_above(c(" " = 2, "Distribuci칩n Territorial" = 3)) %>%
    footnote(
      general = c(
        "Fuente: Elaboraci칩n propia basada en datos del Estado M칠rida 2019-2025",
        "Nota: Una comuna puede tener m칰ltiples categor칤as, pero se cuenta una sola vez por categor칤a"
      ),
      general_title = "",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = tabla_gob_comunas, tabla = tabla_final))
}

# ==============================================================================
# TABLA COMPARATIVA GOBERNACI칍N: PROYECTOS VS COMUNAS
# ==============================================================================
crear_tabla_comparativa_gob <- function(data) {
  
  # Datos por proyectos
  gob_proyectos <- data %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "n_proyectos") %>%
    mutate(pct_proyectos = round(n_proyectos / sum(n_proyectos) * 100, 2))
  
  # Datos por comunas
  gob_comunas <- data %>%
    distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION) %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "n_comunas") %>%
    mutate(pct_comunas = round(n_comunas / sum(n_comunas) * 100, 2))
  
  # Unir ambas tablas
  tabla_comparativa <- gob_proyectos %>%
    inner_join(gob_comunas, by = "CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION") %>%
    arrange(desc(n_proyectos)) %>%
    mutate(
      ranking = row_number(),
      intensidad = round(n_proyectos / n_comunas, 2)  # Proyectos por comuna promedio
    ) %>%
    select(
      ranking,
      CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
      n_proyectos, pct_proyectos,
      n_comunas, pct_comunas,
      intensidad
    ) %>%
    rename(
      "Rank" = ranking,
      "Categor칤a Gobernaci칩n" = CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
      "N춿 Proy." = n_proyectos,
      "% Proy." = pct_proyectos,
      "N춿 Com." = n_comunas,
      "% Com." = pct_comunas,
      "Intensidad" = intensidad
    )
  
  # Crear tabla formateada
  tabla_final <- tabla_comparativa %>%
    kable(
      caption = "Tabla 5.3: An치lisis Comparativo Gobernaci칩n - Proyectos vs Comunas Afectadas",
      align = c("c", "l", rep("c", 5)),
      format = "html",
      digits = 2
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 11
    ) %>%
    column_spec(1, bold = TRUE, color = "white", background = "#8B0000", width = "3em") %>%
    column_spec(2, width = "15em") %>%
    column_spec(3:7, width = "6em") %>%
    add_header_above(c(" " = 2, "Por Proyectos" = 2, "Por Comunas" = 2, "Indicador" = 1)) %>%
    row_spec(1:3, background = "#ffcdd2") %>%  # Top 3 en rojo suave
    row_spec(4:7, background = "#ffecb3") %>%  # Siguientes 4 en amarillo suave
    footnote(
      general = c(
        "Fuente: Elaboraci칩n propia basada en datos del Estado M칠rida 2019-2025",
        "Intensidad = N춿 Proyectos / N춿 Comunas (promedio de proyectos por comuna por categor칤a)"
      ),
      general_title = "",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = tabla_comparativa, tabla = tabla_final))
}

# ==============================================================================
#  TABLA RESUMEN EJECUTIVO GOBERNACI칍N (TOP 10)
# ==============================================================================
crear_tabla_resumen_gob <- function(data) {
  
  # Calcular estad칤sticas resumidas
  total_proyectos <- nrow(data)
  total_comunas <- n_distinct(data$ID_COMUNA)
  
  resumen_gob <- data %>%
    count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "proyectos") %>%
    arrange(desc(proyectos)) %>%
    slice(1:10) %>%  # Solo top 10
    mutate(
      pct_proyectos = round(proyectos / total_proyectos * 100, 1),
      pct_acum = round(cumsum(pct_proyectos), 1)
    ) %>%
    # Agregar datos de comunas
    left_join(
      data %>%
        distinct(ID_COMUNA, CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION) %>%
        count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION, name = "comunas"),
      by = "CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION"
    ) %>%
    mutate(
      pct_comunas = round(comunas / total_comunas * 100, 1),
      posicion = row_number(),
      categoria = case_when(
        posicion <= 3 ~ "游댮 Cr칤tico",
        posicion <= 7 ~ "游리 Alto",
        TRUE ~ "游릭 Medio"
      )
    ) %>%
    select(
      posicion, categoria,
      CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
      proyectos, pct_proyectos, pct_acum,
      comunas, pct_comunas
    ) %>%
    rename(
      "Pos." = posicion,
      "Nivel" = categoria,
      "Categor칤a Gobernaci칩n" = CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION,
      "Proy." = proyectos,
      "%" = pct_proyectos,
      "% Acum." = pct_acum,
      "Com." = comunas,
      "% Com." = pct_comunas
    )
  
  # Crear tabla formateada
  tabla_final <- resumen_gob %>%
    kable(
      caption = "Tabla 5.4: Resumen Ejecutivo - Top 10 Categor칤as de Gobernaci칩n M치s Cr칤ticas",
      align = c("c", "c", "l", rep("c", 5)),
      format = "html"
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center",
      font_size = 11
    ) %>%
    column_spec(1, bold = TRUE, width = "3em") %>%
    column_spec(2, width = "8em") %>%
    column_spec(3, width = "15em") %>%
    column_spec(4:8, width = "5em") %>%
    add_header_above(c(" " = 3, "An치lisis por Proyectos" = 3, "Por Comunas" = 2)) %>%
    footnote(
      general = paste0(
        "Total analizado: ", total_proyectos, " proyectos en ", total_comunas, " comunas. ",
        "El Top 10 concentra el ", round(sum(resumen_gob$`%`), 1), "% de todos los proyectos."
      ),
      general_title = "Nota:",
      footnote_as_chunk = TRUE
    )
  
  return(list(datos = resumen_gob, tabla = tabla_final))
}
```

## **An치lisis de Categor칤as de Gobernaci칩n: Tablas Descriptivas**

En esta secci칩n presentamos el an치lisis detallado de las categor칤as de gobernaci칩n mediante tablas descriptivas que permiten visualizar la distribuci칩n, frecuencia e impacto territorial de los nudos cr칤ticos identificados.

### **Tabla 5.1: Distribuci칩n de Frecuencias de Categor칤as de Gobernaci칩n por N칰mero de Proyectos**

```{r tabla_5.1, echo=FALSE, warning=FALSE}
# Generar tabla de proyectos para Gobernaci칩n
tabla_gob_proyectos <- crear_tabla_gob_proyectos(df_dummies)
tabla_gob_proyectos$tabla
```

*Nota: La tabla muestra la distribuci칩n absoluta y relativa de las categor칤as de gobernaci칩n seg칰n el n칰mero de proyectos asociados.*

### **Tabla 5.2: Distribuci칩n de Frecuencias de Categor칤as de Gobernaci칩n por N칰mero de Comunas Afectadas**

```{r tabla_5.2, echo=FALSE, warning=FALSE}
# Generar tabla de comunas para Gobernaci칩n
tabla_gob_comunas <- crear_tabla_gob_comunas(df_dummies)
tabla_gob_comunas$tabla
```

*Nota: Esta tabla representa la distribuci칩n territorial de las categor칤as de gobernaci칩n, contabilizando cu치ntas comunas est치n afectadas por cada tipo de nudo cr칤tico.*

### **Tabla 5.3: An치lisis Comparativo Gobernaci칩n - Proyectos vs Comunas Afectadas**

```{r tabla_5.3, echo=FALSE, warning=FALSE}
# Generar tabla comparativa para Gobernaci칩n
tabla_gob_comparativa <- crear_tabla_comparativa_gob(df_dummies)
tabla_gob_comparativa$tabla
```

*Nota: El indicador de intensidad (proyectos/comuna) permite identificar categor칤as con mayor concentraci칩n de problemas por territorio.*

### **Tabla 5.4: Resumen Ejecutivo - Top 10 Categor칤as de Gobernaci칩n M치s Cr칤ticas**

```{r tabla_5.4, echo=FALSE, warning=FALSE}
# Generar tabla resumen ejecutivo para Gobernaci칩n
tabla_gob_resumen <- crear_tabla_resumen_gob(df_dummies)
tabla_gob_resumen$tabla
```

*Nota: Clasificaci칩n por nivel de criticidad basado en la frecuencia de aparici칩n y distribuci칩n territorial.*

## **Gr치ficos Adicionales de Distribuci칩n de Proyectos**

```{r graficos_distribucion, echo=FALSE, warning=FALSE}
# Gr치fico de distribuci칩n de n_proyectos
ggplot(df_raw, aes(x = factor(n_proyectos))) +
  geom_bar(aes(fill = factor(n_proyectos)), alpha = 0.8, color = "black") +
  geom_text(aes(label = ..count..), stat = "count", vjust = -0.5, size = 4, fontface = "bold") +
  scale_fill_manual(values = c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728")) +
  labs(title = "Distribuci칩n del n칰mero de proyectos por comuna",
       subtitle = "Per칤odo 2019-2025",
       x = "N칰mero de proyectos",
       y = "Frecuencia",
       fill = "N춿 Proyectos") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom"
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))

# Gr치fico de efectividad por nivel de proyectos
efectividad_data <- df_raw %>%
  group_by(RATIO_ACA_PROYECTO_CULMINADO, n_proyectos) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(RATIO_ACA_PROYECTO_CULMINADO = factor(RATIO_ACA_PROYECTO_CULMINADO,
                                              levels = c(1, 2, 3, 4),
                                              labels = c("Muy Baja", "Baja", "Media", "Alta")))

ggplot(efectividad_data, aes(x = factor(n_proyectos), y = Count, 
                             fill = RATIO_ACA_PROYECTO_CULMINADO)) +
  geom_bar(stat = "identity", position = "stack", alpha = 0.9, color = "white") +
  geom_text(aes(label = Count), position = position_stack(vjust = 0.5), 
            color = "white", fontface = "bold", size = 4) +
  scale_fill_manual(values = c("#e41a1c", "#ff7f00", "#ffff33", "#4daf4a")) +
  labs(title = "Distribuci칩n de efectividad de proyectos por n칰mero de proyectos",
       subtitle = "Agrupado por nivel de participaci칩n en consultas",
       x = "N칰mero de proyectos por comuna",
       y = "Cantidad de proyectos",
       fill = "Nivel de efectividad") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(face = "bold")
  )

# Gr치fico de proporci칩n de efectividad
efectividad_porcentual <- df_raw %>%
  group_by(n_proyectos) %>%
  count(RATIO_ACA_PROYECTO_CULMINADO) %>%
  mutate(Percentage = n / sum(n) * 100,
         RATIO_ACA_PROYECTO_CULMINADO = factor(RATIO_ACA_PROYECTO_CULMINADO,
                                              levels = c(1, 2, 3, 4),
                                              labels = c("Muy Baja", "Baja", "Media", "Alta")))

ggplot(efectividad_porcentual, aes(x = factor(n_proyectos), y = Percentage, 
                                   fill = RATIO_ACA_PROYECTO_CULMINADO)) +
  geom_bar(stat = "identity", position = "fill", alpha = 0.9, color = "white") +
  geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
            position = position_fill(vjust = 0.5), 
            color = "white", fontface = "bold", size = 3.5) +
  scale_fill_manual(values = c("#e41a1c", "#ff7f00", "#ffff33", "#4daf4a")) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(title = "Proporci칩n de efectividad de proyectos por n칰mero de proyectos",
       subtitle = "Distribuci칩n porcentual por nivel de participaci칩n",
       x = "N칰mero de proyectos por comuna",
       y = "Porcentaje",
       fill = "Nivel de efectividad") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(face = "bold")
  )
```

## **Exportaci칩n de Datos de Gobernaci칩n**

```{r exportar_tablas_gob, echo=FALSE, warning=FALSE, eval=FALSE}
# Funci칩n para exportar tablas de Gobernaci칩n (opcional)
exportar_tablas_gob <- function(tablas_objeto, ruta = "tablas_gob/") {
  
  # Crear directorio si no existe
  if (!dir.exists(ruta)) dir.create(ruta, recursive = TRUE)
  
  # Exportar datos a CSV
  write.csv(tablas_objeto$proyectos$datos, 
            paste0(ruta, "gob_por_proyectos.csv"), 
            row.names = FALSE)
  
  write.csv(tablas_objeto$comunas$datos, 
            paste0(ruta, "gob_por_comunas.csv"), 
            row.names = FALSE)
  
  write.csv(tablas_objeto$comparativa$datos, 
            paste0(ruta, "gob_comparativa.csv"), 
            row.names = FALSE)
  
  write.csv(tablas_objeto$resumen$datos, 
            paste0(ruta, "gob_resumen_ejecutivo.csv"), 
            row.names = FALSE)
  
  cat("Tablas de Gobernaci칩n exportadas exitosamente a:", ruta, "\n")
}

# Crear objeto con todas las tablas de Gobernaci칩n (para exportaci칩n si es necesario)
tablas_gob <- list(
  proyectos = tabla_gob_proyectos,
  comunas = tabla_gob_comunas,
  comparativa = tabla_gob_comparativa,
  resumen = tabla_gob_resumen
)

# Para exportar, quitar eval=FALSE del chunk
# exportar_tablas_gob(tablas_gob)
```

## **Resumen Interpretativo del An치lisis de Gobernaci칩n**

Los resultados muestran que las categor칤as de gobernaci칩n presentan distribuciones heterog칠neas tanto en frecuencia de proyectos como en alcance territorial. Las primeras cuatro categor칤as concentran m치s del 50% de los proyectos, indicando 치reas prioritarias para la intervenci칩n.

## **Desarrollamos indice Shannon y Pielou**

## **Indice Shannon y Pielou por Comunas y Tipolog칤a CFG y de Gobernaci칩n**

```{r, fig.width=16, fig.height=12, out.width="100%"}

#--------------------------Crear mapeo 칰nico de ID_COMUNA a COMUNA-----------------------------
commune_map <- df_raw %>%
  distinct(ID_COMUNA, COMUNA) %>%
  mutate(COMUNA = str_trim(COMUNA))  # Limpiar espacios extras

## Detectar din치micamente las columnas dummy
cfg_cols <- grep("^CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_", 
                 names(df_dummies), value = TRUE)
gob_cols <- grep("^CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_", 
                 names(df_dummies), value = TRUE)

## Calcular diversidad para las Tipolog칤a CFG con nombres de comunas
div_cfg <- df_dummies %>%
  group_by(ID_COMUNA) %>%
  summarise(
    n_proyectos = n(),
    across(all_of(cfg_cols), sum, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # Agregar nombres de comunas
  left_join(commune_map, by = "ID_COMUNA") %>%
  # Calcular 칤ndices de diversidad
  {
    cnts <- select(., all_of(cfg_cols))
    tib <- select(., ID_COMUNA, COMUNA, n_proyectos)
    H <- vegan::diversity(cnts, index = "shannon")
    richesse <- rowSums(cnts > 0)
    J <- ifelse(richesse > 0, H / log(richesse), NA_real_)
    bind_cols(tib, H_shannon = H, pielou = J)
  }

# Crear columna combinada para mostrar en tablas
div_cfg <- div_cfg %>%
  mutate(COMUNA_ID_NOMBRE = paste(ID_COMUNA, "-", COMUNA))

# Tabla: Top 10 comunas m치s diversas (con ID y nombre)
top10_cfg <- div_cfg %>%
  arrange(desc(H_shannon)) %>%
  slice(1:10) %>%
  select(COMUNA_ID_NOMBRE, H_shannon, pielou, n_proyectos)

# Tabla: Top 10 comunas menos diversas (con ID y nombre)
bottom10_cfg <- div_cfg %>%
  arrange(H_shannon) %>%
  slice(1:10) %>%
  select(COMUNA_ID_NOMBRE, H_shannon, pielou, n_proyectos)

# Mostrar tablas en formato kable para Tipolog칤a CFG
cat("\n\n**10 comunas con mayor diversidad (Shannon_CFG)**\n")
knitr::kable(top10_cfg, 
             col.names = c("Comuna (ID - Nombre)", "H_CFG (Shannon)", "J_CFG (Pielou)", "N춿 Proyectos"),
             digits = 3,
             caption = "Top 10 comunas con mayor 칤ndice de Shannon para CFG")

cat("\n\n**10 comunas con menor diversidad (Shannon_CFG)**\n")
knitr::kable(bottom10_cfg,
             col.names = c("Comuna (ID - Nombre)", "H_CFG (Shannon)", "J_CFG (Pielou)", "N춿 Proyectos"),
             digits = 3,
             caption = "Top 10 comunas con menor 칤ndice de Shannon para CFG")

## Preparar datos para gr치fico consolidado para CFG
tabla_extremos_cfg <- bind_rows(
  top10_cfg  %>% mutate(tipo = "Top 10 ") %>% rename(COMUNA = COMUNA_ID_NOMBRE),
  bottom10_cfg %>% mutate(tipo = "Top 10 ") %>% rename(COMUNA = COMUNA_ID_NOMBRE)
) %>%
  # Crear etiqueta ordenada por H_shannon
  mutate(COMUNA_ORD = reorder(COMUNA, H_shannon))

#---------------Gr치fico: Shannon (barras) + Pielou (l칤nea) para CFG------------------------#
maxH <- max(tabla_extremos_cfg$H_shannon)

# Ajustar el gr치fico con dimensiones espec칤ficas
cfg_plot <- ggplot(tabla_extremos_cfg, aes(x = COMUNA_ORD, y = H_shannon, fill = tipo)) +
  geom_line(aes(y = pielou * maxH, group = 1), 
            color = "#E69F00", size = 1.0, linetype = "dashed") +
  geom_point(aes(y = pielou * maxH), 
             color = "#D55E00", size = 2.5, shape = 18) +
  # Etiquetas de Pielou desplazadas a la derecha
  geom_text(aes(y = pielou * maxH, label = sprintf("J=%.2f", pielou)),
            hjust = -0.3, size = 2.5, color = "#D55E00") +  # Ajustado hjust

  geom_col(width = 0.7, alpha = 0.9) +
  geom_text(aes(y = H_shannon, label = sprintf("%.2f (%.1f)", H_shannon, exp(H_shannon))),
            hjust = 1.1, size = 2.8, color = "white", fontface = "bold") +  # Tama침o ajustado
  facet_wrap(~ tipo, scales = "free_y", ncol = 1) +
  coord_flip() +
  scale_y_continuous(
    name = "칈ndice de Shannon (H)",
    limits = c(0, maxH * 1.15), 
    sec.axis = sec_axis(~ . / maxH, name = "칈ndice de Pielou (J)",
                        labels = scales::number_format(accuracy = 0.1))
  ) +
  scale_fill_manual(values = c("Top 10 " = "#56B4E9", "Top 10 " = "#CC79A7")) +
  labs(
    title = "Diversidad de Tipolog칤as CFG por Comuna",
    subtitle = "Top 10 comunas con mayor y menor diversidad | Barras: Shannon (H) | L칤nea: Pielou (J)",
    x = "Comuna (ID - Nombre)",
    caption = "Fuente: Elaboraci칩n propia datos de proyectos ACA - William Gutierrez"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(size = 10, color = "gray40", hjust = 0.5),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.y = element_text(size = 8),  # Reducir tama침o texto eje Y
    panel.grid.major.y = element_blank(),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none",
    plot.margin = margin(1, 2, 1, 1, "cm")  # Aumentar margen derecho
  )

# Guardar con dimensiones espec칤ficas
ggsave("cfg_diversity_plot.png", cfg_plot, width = 14, height = 10, dpi = 300)
print(cfg_plot)

## Calcular diversidad para Tipolog칤a de Gobernaci칩n con nombres
div_gob <- df_dummies %>%
  group_by(ID_COMUNA) %>%
  summarise(
    n_proyectos = n(),
    across(all_of(gob_cols), sum, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # Agregar nombres de comunas
  left_join(commune_map, by = "ID_COMUNA") %>%
  # Calcular 칤ndices de diversidad
  {
    cnts <- select(., all_of(gob_cols))
    tib <- select(., ID_COMUNA, COMUNA, n_proyectos)
    H <- vegan::diversity(cnts, index = "shannon")
    richesse <- rowSums(cnts > 0)
    J <- ifelse(richesse > 0, H / log(richesse), NA_real_)
    bind_cols(tib, H_shannon = H, pielou = J)
  }

# Crear columna combinada para mostrar en tablas
div_gob <- div_gob %>%
  mutate(COMUNA_ID_NOMBRE = paste(ID_COMUNA, "-", COMUNA))

## Mostrar tablas con nombres
top10_gob <- div_gob %>% 
  arrange(desc(H_shannon)) %>% 
  slice(1:10) %>%
  select(COMUNA_ID_NOMBRE, n_proyectos, H_shannon, pielou)

bottom10_gob <- div_gob %>% 
  arrange(H_shannon) %>% 
  slice(1:10) %>%
  select(COMUNA_ID_NOMBRE, n_proyectos, H_shannon, pielou)

cat("\n\n**Top 10 comunas con mayor diversidad (Shannon) de Gobernaci칩n**\n")
knitr::kable(top10_gob,
             col.names = c("Comuna (ID - Nombre)", "N춿 Proyectos", "H_GOB (Shannon)", "J_GOB (Pielou)"),
             digits = 3, 
             caption = "Top 10 comunas con mayor 칤ndice de Shannon para Gobernaci칩n")

cat("\n\n**Top 10 comunas con menor diversidad (Shannon) de Gobernaci칩n**\n")
knitr::kable(bottom10_gob,
             col.names = c("Comuna (ID - Nombre)", "N춿 Proyectos", "H_GOB (Shannon)", "J_GOB (Pielou)"),
             digits = 3, 
             caption = "Top 10 comunas con menor 칤ndice de Shannon para Gobernaci칩n")

## Preparar datos para gr치fico de Gobernaci칩n
tabla_extremos_gob <- bind_rows(
  top10_gob %>% mutate(tipo = "Top 10 ") %>% rename(COMUNA = COMUNA_ID_NOMBRE),
  bottom10_gob %>% mutate(tipo = "Top 10 ") %>% rename(COMUNA = COMUNA_ID_NOMBRE)
) %>%
  # Crear etiqueta ordenada por H_shannon
  mutate(COMUNA_ORD = reorder(COMUNA, H_shannon))


#-------------------------Gr치fica de tipolog칤a de gobernaci칩n-----------------------------#
maxH_gob <- max(tabla_extremos_gob$H_shannon)

gob_plot <- ggplot(tabla_extremos_gob, aes(x = COMUNA_ORD, y = H_shannon, fill = tipo)) +
  geom_line(aes(y = pielou * maxH_gob, group = 1), 
            color = "#E69F00", size = 1.0, linetype = "dashed") +
  geom_point(aes(y = pielou * maxH_gob), 
             color = "#D55E00", size = 2.5, shape = 18) +
  # Etiquetas de Pielou desplazadas a la derecha
  geom_text(aes(y = pielou * maxH_gob, label = sprintf("J=%.2f", pielou)),
            hjust = -0.2, size = 2.5, color = "#D55E00") +
  # Luego dibujar las barras de Shannon
  geom_col(width = 0.7, alpha = 0.9) +
  geom_text(aes(y = H_shannon, label = sprintf("%.2f (%.1f)", H_shannon, exp(H_shannon))),
            hjust = 1.1, size = 2.8, color = "white", fontface = "bold") +
  facet_wrap(~ tipo, scales = "free_y", ncol = 1) +
  coord_flip() +
  scale_y_continuous(
    name = "칈ndice de Shannon (H)",
    limits = c(0, maxH_gob * 1.15),
    sec.axis = sec_axis(~ . / maxH_gob, name = "칈ndice de Pielou (J)",
                        labels = scales::number_format(accuracy = 0.1))
  ) +
  scale_fill_manual(values = c("Top 10 " = "#56B4E9", "Top 10 " = "#CC79A7")) +
  labs(
    title = "Diversidad Institucional (Gobernaci칩n) por Comuna",
    subtitle = "Top 10 comunas con mayor y menor diversidad | Barras: Shannon (H) | L칤nea: Pielou (J)",
    x = "Comuna (ID - Nombre)",
    caption = "Fuente: Elaboraci칩n propia datos de proyectos ACA - William Gutierrez"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(size = 10, color = "gray40", hjust = 0.5),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.y = element_text(size = 8),  # Reducir tama침o texto eje Y
    panel.grid.major.y = element_blank(),
    strip.text = element_text(face = "bold", size = 11),
    legend.position = "none",
    plot.margin = margin(1, 2, 1, 1, "cm")  # Aumentar margen derecho
  )

# Guardar con dimensiones espec칤ficas
ggsave("gob_diversity_plot.png", gob_plot, width = 14, height = 10, dpi = 300)
print(gob_plot)

```


## **Indice Shannon de ratio de proyecto por tipolog칤as**

```{r, fig.width=16, fig.height=12, out.width="100%"}


## **Indice Shannon de ratio de proyecto por tipolog칤as**

# Filtrar y preparar datos para Ratio
df_ratio_clean <- df_raw %>% 
  filter(!is.na(RATIO_ACA_PROYECTO_CULMINADO)) %>%  
  mutate(
    RATIO_ACA_PROYECTO_CULMINADO = factor(
      RATIO_ACA_PROYECTO_CULMINADO,
      levels = 1:4,
      labels = c("MUY BAJA", "BAJA", "MEDIA", "ALTA")
    )
  )

# Crear datos wide para diversidad
df_ratio_wide <- df_ratio_clean %>%
  group_by(ID_COMUNA, RATIO_ACA_PROYECTO_CULMINADO) %>%
  summarise(n = n(), .groups = "drop") %>%
  complete(ID_COMUNA, RATIO_ACA_PROYECTO_CULMINADO, fill = list(n = 0)) %>%
  pivot_wider(
    names_from = RATIO_ACA_PROYECTO_CULMINADO, 
    values_from = n, 
    names_prefix = "ratio_"
  )

# Asegurar que todas las columnas de ratio existan
ratio_cols <- c("ratio_MUY BAJA", "ratio_BAJA", "ratio_MEDIA", "ratio_ALTA")
for (col in ratio_cols) {
  if (!col %in% names(df_ratio_wide)) {
    df_ratio_wide[[col]] <- 0
  }
}

# Calcular diversidad para Ratio
div_ratio <- df_ratio_wide %>%
  left_join(commune_map, by = "ID_COMUNA") %>%
  mutate(n_proyectos_ratio = rowSums(select(., all_of(ratio_cols)))) %>%
  {
    cnts <- select(., all_of(ratio_cols))
    tib <- select(., ID_COMUNA, COMUNA, n_proyectos_ratio)
    H <- vegan::diversity(cnts, index = "shannon")
    richesse <- rowSums(cnts > 0)
    J <- ifelse(richesse > 0, H / log(richesse), NA_real_)
    bind_cols(tib, H_shannon = H, pielou = J)
  } %>%
  mutate(COMUNA_ID_NOMBRE = paste(ID_COMUNA, "-", COMUNA))

# Crear top y bottom 10
top10_ratio <- div_ratio %>%
  arrange(desc(H_shannon)) %>%
  slice(1:10) %>%
  select(COMUNA_ID_NOMBRE, n_proyectos_ratio, H_shannon, pielou)

bottom10_ratio <- div_ratio %>%
  arrange(H_shannon) %>%
  slice(1:10) %>%
  select(COMUNA_ID_NOMBRE, n_proyectos_ratio, H_shannon, pielou)

# Preparar datos para gr치fico
tabla_extremos_ratio <- bind_rows(
  top10_ratio %>% 
    mutate(tipo = "Mayor diversidad (Top 10)") %>% 
    rename(COMUNA = COMUNA_ID_NOMBRE),
  bottom10_ratio %>% 
    mutate(tipo = "Menor diversidad (Bottom 10)") %>% 
    rename(COMUNA = COMUNA_ID_NOMBRE)
) %>%
  mutate(
    etiqueta_H = sprintf("H: %.2f", H_shannon),
    etiqueta_J = sprintf("J: %.2f", pielou)
  )
## Tabla completa (Todas las comunas)
div_ratio_completo <- div_ratio %>%
  select(COMUNA_ID_NOMBRE, n_proyectos_ratio, H_shannon, pielou) %>%
  arrange(desc(H_shannon)) %>%
  mutate(
    H_shannon = round(H_shannon, 3),
    pielou = round(pielou, 3),
    # Interpretaci칩n r치pida
    Interpretacion = case_when(
      H_shannon < 0.5 ~ "Baja diversidad",
      H_shannon >= 0.5 & H_shannon < 1.0 ~ "Diversidad media",
      H_shannon >= 1.0 ~ "Alta diversidad"
    )
  )

# Mostrar tabla completa ordenada por diversidad
cat("\n\n**Diversidad de Ratio ACA en todas las comunas**\n")
knitr::kable(
  div_ratio_completo,
  col.names = c("Comuna (ID - Nombre)", "Proyectos", "H (Shannon)", "J (Pielou)", "Interpretaci칩n"),
  digits = 3,
  caption = "Diversidad de estados de culminaci칩n en todas las comunas"
)

# Preparar datos para gr치fico (sin crear etiquetas pre-definidas)
tabla_extremos_ratio <- bind_rows(
  top10_ratio %>% 
    mutate(tipo = "Mayor diversidad (Top 10)") %>% 
    rename(COMUNA = COMUNA_ID_NOMBRE),
  bottom10_ratio %>% 
    mutate(tipo = "Menor diversidad (Bottom 10)") %>% 
    rename(COMUNA = COMUNA_ID_NOMBRE)
)
# Nota: Removimos las etiquetas pre-definidas etiqueta_H y etiqueta_J

# Calcular maxH_ratio
maxH_ratio <- max(tabla_extremos_ratio$H_shannon, na.rm = TRUE) * 1.3

# Crear gr치fico con valores exponenciales en las etiquetas
ratio_plot <- ggplot(tabla_extremos_ratio, aes(x = reorder(COMUNA, H_shannon), y = H_shannon, fill = tipo)) +
  geom_col(alpha = 0.85, width = 0.7) +
  
  # Etiquetas de Shannon con valor exponencial
  geom_text(
    aes(label = sprintf("%.2f (%.1f)", H_shannon, exp(H_shannon)), y = H_shannon * 0.5), 
    color = "white", 
    fontface = "bold",
    size = 2.8  # Reducido ligeramente
  ) +
  
  # Etiquetas de Pielou
  geom_text(
    aes(label = sprintf("J=%.2f", pielou), y = H_shannon + 0.05 * maxH_ratio),
    color = "#D55E00",
    size = 2.8,  # Reducido
    hjust = 0
  ) +
  
  # L칤nea y puntos de Pielou
  geom_line(
    aes(y = pielou * maxH_ratio, group = tipo), 
    color = "#E69F00", 
    linewidth = 1.2, 
    linetype = "solid"
  ) +
  geom_point(
    aes(y = pielou * maxH_ratio), 
    color = "#D55E00", 
    size = 3, 
    shape = 18
  ) +
  
  # Configuraci칩n del gr치fico
  facet_wrap(
    ~ tipo, 
    scales = "free_y", 
    ncol = 1,
    strip.position = "top"
  ) +
  coord_flip() +
  scale_y_continuous(
    name = "칈ndice de Shannon (H)",
    sec.axis = sec_axis(
      ~ . / maxH_ratio, 
      name = "칈ndice de Pielou (J)",
      labels = scales::number_format(accuracy = 0.1)
    ),
    expand = expansion(mult = c(0, 0.15))
  ) +
  scale_fill_manual(values = c(
    "Mayor diversidad (Top 10)" = "#1b9e77", 
    "Menor diversidad (Bottom 10)" = "#d95f02"
  )) +
  labs(
    title = "Diversidad de estados de culminaci칩n de proyectos",
    subtitle = "Comunas con mayor y menor diversidad en estados de proyectos (Ratio ACA)",
    x = "Comuna (ID - Nombre)",
    caption = "Fuente: Elaboraci칩n propia - Proyectos ACA (2022-2025)\nNota: Barras = Shannon (H) con valor exponencial, L칤nea = Pielou (J)"
  ) +
  theme_minimal(base_size = 11) +  # Base size reducido
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),  # T칤tulo m치s peque침o
    plot.subtitle = element_text(size = 11, color = "gray30", hjust = 0.5),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.y = element_text(size = 8),  # Texto del eje Y m치s peque침o
    panel.grid.major.y = element_blank(),
    strip.text = element_text(face = "bold", size = 11, color = "white"),
    strip.background = element_rect(fill = "gray25", color = NA),
    legend.position = "none",
    panel.spacing = unit(1, "lines"),
    plot.margin = margin(1, 2, 1, 1, "cm")  # Margen derecho aumentado
  )

# Guardar con dimensiones espec칤ficas
ggsave("ratio_diversity_plot.png", ratio_plot, width = 14, height = 10, dpi = 300)
print(ratio_plot)
```

## **Visualizaci칩n de los resultados**

```{r}
# -----------------------------------------------------------------------------
# FUNCI칍N PARA LIMPIAR EL ENTORNO (OPCIONAL)
# -----------------------------------------------------------------------------
limpiar_objetos_analisis <- function() {
  objetos_a_limpiar <- c("div_combinada", "tipo_comuna_stats", 
                        "div_cfg_con_tipo", "div_gob_con_tipo", "div_ratio_con_tipo")
  objetos_existentes <- objetos_a_limpiar[objetos_a_limpiar %in% ls(envir = .GlobalEnv)]
  if(length(objetos_existentes) > 0) {
    rm(list = objetos_existentes, envir = .GlobalEnv)
    cat("Limpiados objetos:", paste(objetos_existentes, collapse = ", "), "\n")
  }
}

# Ejecutar si quieres limpiar (descomenta la siguiente l칤nea)
# limpiar_objetos_analisis()

# -----------------------------------------------------------------------------
# CLASIFICACI칍N COMPLETA Y CREACI칍N DEL TIPO DE COMUNA
# -----------------------------------------------------------------------------
crear_mapa_comunas <- function(df_source) {
  # Esta funci칩n crea el mapa de comunas de forma limpia cada vez
  mapa <- df_source %>%
    distinct(ID_COMUNA, COMUNA, COD_CC) %>%
    mutate(
      COMUNA = str_trim(COMUNA),
      Tipo_Comuna = case_when(
        str_detect(COD_CC, "C-URB") ~ "Urbana",
        str_detect(COD_CC, "C-RUR") ~ "Rural", 
        str_detect(COD_CC, "C-MIX") ~ "Mixta",
        str_detect(COD_CC, "^\\d{2}-\\d{2}-\\d{4}$") ~ "En construcci칩n",
        str_detect(COD_CC, "^\\d{2}-\\d{2}-\\d{2}") ~ "En construcci칩n",
        str_detect(COD_CC, "^CEC") ~ "En construcci칩n",
        TRUE ~ "No especificado"
      )
    )
  
  return(mapa)
}

# Verificar distribuci칩n
table(commune_map$Tipo_Comuna)

# Crear el mapa de comunas fresco cada vez
commune_map <- crear_mapa_comunas(df_raw)

# Verificar distribuci칩n
cat("Distribuci칩n de tipos de comuna:\n")
print(table(commune_map$Tipo_Comuna))


# =============================================================================
# AN츼LISIS INTEGRAL 칈NDICE SHANNON - POL칈TICAS P칔BLICAS ACA
# =============================================================================

# -----------------------------------------------------------------------------
# PALETA DE COLORES Y TEMA COM칔N
# -----------------------------------------------------------------------------
colores_comuna <- c(
  "Urbana" = "#2E86AB",           # Azul - densidad urbana
  "Rural" = "#A23B72",            # Magenta - ruralidad
  "Mixta" = "#F18F01",            # Naranja - combinaci칩n
  "En construcci칩n" = "#C73E1D",   # Rojo - desarrollo
  "No especificado" = "#7D8491"    # Gris - sin clasificar
)

tema_comun <- theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5, color = "#2E86AB"),
    plot.subtitle = element_text(size = 12, color = "gray40", hjust = 0.5),
    axis.title = element_text(face = "bold", size = 11),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 11, color = "#2E86AB"),
    strip.background = element_rect(fill = "gray95", color = "white"),
    panel.border = element_rect(color = "gray90", fill = NA),
    legend.title = element_text(face = "bold")
  )

# -----------------------------------------------------------------------------
# PREPARACI칍N DE DATOS
# -----------------------------------------------------------------------------
# Crear mapa de comunas
commune_map <- df_raw %>%
  distinct(ID_COMUNA, COMUNA, COD_CC) %>%
  mutate(
    COMUNA = str_trim(COMUNA),
    Tipo_Comuna = case_when(
      str_detect(COD_CC, "C-URB") ~ "Urbana",
      str_detect(COD_CC, "C-RUR") ~ "Rural", 
      str_detect(COD_CC, "C-MIX") ~ "Mixta",
      str_detect(COD_CC, "^\\d{2}-\\d{2}-\\d{4}$") ~ "En construcci칩n",
      str_detect(COD_CC, "^\\d{2}-\\d{2}-\\d{2}") ~ "En construcci칩n",
      str_detect(COD_CC, "^CEC") ~ "En construcci칩n",
      TRUE ~ "No especificado"
    )
  )

# Agregar tipo de comuna a cada dataset
div_cfg_con_tipo <- div_cfg %>%
  select(-contains("Tipo_Comuna")) %>%
  left_join(commune_map %>% select(ID_COMUNA, Tipo_Comuna), by = "ID_COMUNA")

div_gob_con_tipo <- div_gob %>%
  select(-contains("Tipo_Comuna")) %>%
  left_join(commune_map %>% select(ID_COMUNA, Tipo_Comuna), by = "ID_COMUNA")

div_ratio_con_tipo <- div_ratio %>%
  select(-contains("Tipo_Comuna")) %>%
  left_join(commune_map %>% select(ID_COMUNA, Tipo_Comuna), by = "ID_COMUNA")

# Combinar datasets
div_combinada <- bind_rows(
  div_cfg_con_tipo %>%
    select(COMUNA_ID_NOMBRE, n_proyectos, H_shannon, pielou, Tipo_Comuna) %>%
    mutate(Tipo_Analisis = "CFG"),
  
  div_gob_con_tipo %>%
    select(COMUNA_ID_NOMBRE, n_proyectos, H_shannon, pielou, Tipo_Comuna) %>%
    mutate(Tipo_Analisis = "Gobernaci칩n"),
  
  div_ratio_con_tipo %>%
    select(COMUNA_ID_NOMBRE, n_proyectos = n_proyectos_ratio, H_shannon, pielou, Tipo_Comuna) %>%
    mutate(Tipo_Analisis = "Ratio ACA")
) %>%
  mutate(
    Shannon_Categoria = case_when(
      H_shannon < 0.5 ~ "Muy Baja",
      H_shannon < 1.0 ~ "Baja", 
      H_shannon < 1.5 ~ "Media",
      H_shannon >= 1.5 ~ "Alta"
    ),
    Eficiencia = H_shannon / (n_proyectos + 0.1)
  ) %>%
  filter(!is.na(H_shannon), !is.na(Tipo_Comuna), is.finite(H_shannon))

# -----------------------------------------------------------------------------
# ESTAD칈STICAS DESCRIPTIVAS
# -----------------------------------------------------------------------------
stats_shannon <- div_combinada %>%
  group_by(Tipo_Analisis, Tipo_Comuna) %>%
  summarise(
    n = n(),
    mean_shannon = mean(H_shannon, na.rm = TRUE),
    sd_shannon = sd(H_shannon, na.rm = TRUE),
    median_shannon = median(H_shannon, na.rm = TRUE),
    se = sd_shannon / sqrt(n),
    .groups = "drop"
  ) %>%
  filter(n >= 2)

# Mostrar tabla de estad칤sticas
kable(stats_shannon,
      caption = "Estad칤sticas del 칈ndice Shannon por Tipo de Comuna y An치lisis",
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# -----------------------------------------------------------------------------
# GR츼FICOS
# -----------------------------------------------------------------------------

# 1. Distribuci칩n Shannon
grafico_1_distribucion <- ggplot(div_combinada, aes(x = Tipo_Comuna, y = H_shannon, fill = Tipo_Comuna)) +
  geom_violin(alpha = 0.7, trim = FALSE, color = "white", linewidth = 0.8) +
  geom_boxplot(width = 0.2, fill = "white", outlier.colour = "#2E86AB", 
               outlier.size = 2, color = "black", linewidth = 0.5) +
  geom_jitter(aes(color = Tipo_Comuna), width = 0.15, size = 1.8, alpha = 0.6) +
  scale_fill_manual(values = colores_comuna, name = "Tipo de Comuna") +
  scale_color_manual(values = colores_comuna, name = "Tipo de Comuna") +
  facet_wrap(~ Tipo_Analisis, scales = "free_y") +
  labs(
    title = "Distribuci칩n del 칈ndice de Shannon por Tipo de Comuna",
    subtitle = "An치lisis de diversidad en Agendas Concretas de Acci칩n - M칠rida, Venezuela",
    y = "칈ndice de Shannon (H')", 
    x = "Tipo de Comuna",
    caption = "Elaborado por: William Guti칠rrez"
  ) +
  tema_comun

print(grafico_1_distribucion)

# 2. Relaci칩n proyectos-Shannon
grafico_2_relacion <- ggplot(div_combinada, aes(x = n_proyectos, y = H_shannon)) +
  geom_point(aes(color = Tipo_Comuna), size = 3, alpha = 0.7) +
  geom_smooth(method = "loess", se = TRUE, color = "#2E86AB", 
              fill = "#2E86AB", alpha = 0.2, linewidth = 1.2) +
  scale_color_manual(values = colores_comuna, name = "Tipo de Comuna") +
  facet_wrap(~ Tipo_Analisis, scales = "free") +
  labs(
    title = "Relaci칩n entre N칰mero de Proyectos y Diversidad Shannon",
    subtitle = "An치lisis de correlaci칩n en pol칤ticas ACA",
    x = "N칰mero de Proyectos",
    y = "칈ndice de Shannon (H')",
    caption = "Elaborado por: William Guti칠rrez"
  ) +
  tema_comun

print(grafico_2_relacion)

# 3. Comparativa de medias con intervalos de confianza
grafico_3_comparativa <- ggplot(stats_shannon, 
                               aes(x = reorder(Tipo_Comuna, mean_shannon), 
                                   y = mean_shannon, fill = Tipo_Comuna)) +
  geom_col(alpha = 0.8, color = "white", linewidth = 0.8) +
  geom_errorbar(aes(ymin = pmax(0, mean_shannon - se), 
                    ymax = mean_shannon + se), 
                width = 0.3, color = "black", linewidth = 0.8) +
  geom_text(aes(label = sprintf("%.2f", mean_shannon)), 
            vjust = -1.5, size = 4, fontface = "bold", color = "#2E86AB") +
  scale_fill_manual(values = colores_comuna, name = "Tipo de Comuna") +
  facet_wrap(~ Tipo_Analisis, scales = "free_y") +
  labs(
    title = "칈ndice de Shannon Promedio por Tipo de Comuna",
    subtitle = "Barras de error representan error est치ndar de la media",
    x = "Tipo de Comuna",
    y = "Shannon Promedio (H')",
    caption = "Elaborado por: William Guti칠rrez"
  ) +
  tema_comun

print(grafico_3_comparativa)

# 4. Heatmap de frecuencias
datos_heatmap <- div_combinada %>%
  filter(Tipo_Analisis %in% c("CFG", "Gobernaci칩n")) %>%
  count(Tipo_Analisis, Tipo_Comuna, Shannon_Categoria) %>%
  complete(Tipo_Analisis, Tipo_Comuna, Shannon_Categoria, fill = list(n = 0))

grafico_4_heatmap <- ggplot(datos_heatmap, 
                           aes(x = Shannon_Categoria, y = Tipo_Comuna, fill = n)) +
  geom_tile(color = "white", linewidth = 0.8) +
  geom_text(aes(label = n, 
                color = ifelse(n >= max(n)/2, "white", "black")), 
            fontface = "bold", size = 4) +
  scale_fill_gradient(
    low = "#C6DBEF",    # Azul claro
    high = "#08519C",   # Azul oscuro
    name = "Frecuencia"
  ) +
  scale_color_identity() +
  facet_wrap(~ Tipo_Analisis) +
  labs(
    title = "Distribuci칩n de Frecuencias: Tipo Comuna vs. Shannon",
    subtitle = "Mapa de calor para an치lisis CFG y Gobernaci칩n",
    x = "Categor칤a Shannon",
    y = "Tipo de Comuna",
    caption = "Elaborado por: William Guti칠rrez"
  ) +
  tema_comun

print(grafico_4_heatmap)

# 5. 칈ndice de Pielou vs Shannon
grafico_5_pielou <- ggplot(div_combinada, aes(x = n_proyectos, y = H_shannon)) +
  geom_point(aes(color = Tipo_Comuna), size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "#2E86AB", 
              fill = "#2E86AB", alpha = 0.2, linewidth = 1.2) +
  scale_color_manual(values = colores_comuna, name = "Tipo de Comuna") +
  facet_wrap(~ Tipo_Analisis) +
  labs(
    title = "Relaci칩n entre N칰mero de Proyectos y Shannon",
    subtitle = "An치lisis de proyectos y diversidad en ACA",
    x = "N칰mero de Proyectos",
    y = "칈ndice de Shannon (H')",
    caption = "Elaborado por: William Guti칠rrez"
  ) +
  tema_comun

print(grafico_5_pielou)

```

## **Aplicaci칩n de normalidad**

```{r}
## Preparaci칩n de los datos
 # Eliminar valores nulos si es necesario
df_clean <- df_raw %>% filter(!is.na(n_proyectos) & !is.na(PLAZOS) & !is.na(CLASIFICACION_DEL_PROYECTO)& !is.na(RATIO_ACA_PROYECTO_CULMINADO)& !is.na(Clasificacion_Actores_institucionales)& !is.na(TIPOLOGIA_CFG_NUM)& !is.na(GOBERNACION_NUM))

# Funci칩n para crear un panel de diagn칩stico de normalidad
create_normality_diagnostic <- function(data, variable, variable_name) {
  # Datos para la variable
  x <- data[[variable]]
  
  # Histograma con curva de densidad
  p1 <- ggplot(data, aes_string(x = variable)) +
    geom_histogram(aes(y = ..density..), bins = 30, fill = "lightblue", color = "black", alpha = 0.7) +
    geom_density(color = "red", linewidth = 1) +
    stat_function(fun = dnorm, 
                 args = list(mean = mean(x, na.rm = TRUE), 
                           sd = sd(x, na.rm = TRUE)),
                 color = "blue", linewidth = 1, linetype = "dashed") +
    labs(title = paste("Histograma y Densidad -", variable_name),
         x = variable_name, y = "Densidad") +
    theme_minimal()
  
  # Q-Q plot
  p2 <- ggplot(data, aes(sample = x)) +
    stat_qq() +
    stat_qq_line(color = "red") +
    labs(title = paste("Q-Q Plot -", variable_name)) +
    theme_minimal()
  
  # Combinar los gr치ficos
  gridExtra::grid.arrange(p1, p2, ncol = 2)
}

# Lista de variables para analizar
variables_to_analyze <- list(
  "n_proyectos" = "N칰mero de Proyectos",
  "RATIO_ACA_PROYECTO_CULMINADO" = "Ratio ACA",
  "TIPOLOGIA_CFG_NUM" = "Tipolog칤a CFG",
  "GOBERNACION_NUM" = "Gobernaci칩n",
  "PLAZOS" = "Plazos",
  "CLASIFICACION_DEL_PROYECTO" = "Clasificaci칩n del Proyecto",
  "Clasificacion_Actores_institucionales" = "Actores Institucionales"
)

# Crear un panel para cada variable
for(var in names(variables_to_analyze)) {
  cat("\n\nAn치lisis de normalidad para:", variables_to_analyze[[var]], "\n")
  print(create_normality_diagnostic(df_clean, var, variables_to_analyze[[var]]))
  
  # Imprimir resultados del test de Shapiro-Wilk
  sw_test <- shapiro.test(df_clean[[var]])
  cat("\nTest de Shapiro-Wilk:\n")
  cat("W =", round(sw_test$statistic, 4), "\n")
  cat("p-value =", format.pval(sw_test$p.value, digits = 4), "\n")
  cat("-----------------------------------\n")
}

# Preparar el espacio para m칰ltiples gr치ficos
par(mfrow = c(2, 4))  # 2 filas x 4 columnas para acomodar todos los Q-Q plots

# Crear Q-Q plots para cada variable con t칤tulos descriptivos
qqnorm(df_clean$n_proyectos, main="Q-Q Plot: N춿 Proyectos",
       col = "blue", pch = 19)
qqline(df_clean$n_proyectos, col = "red")

qqnorm(df_clean$RATIO_ACA_PROYECTO_CULMINADO, main="Q-Q Plot: Ratio ACA",
       col = "green4", pch = 19)
qqline(df_clean$RATIO_ACA_PROYECTO_CULMINADO, col = "red")

qqnorm(df_clean$TIPOLOGIA_CFG_NUM, main="Q-Q Plot: Tipolog칤a CFG",
       col = "purple", pch = 19)
qqline(df_clean$TIPOLOGIA_CFG_NUM, col = "red")

qqnorm(df_clean$GOBERNACION_NUM, main="Q-Q Plot: Gobernaci칩n",
       col = "orange", pch = 19)
qqline(df_clean$GOBERNACION_NUM, col = "red")

qqnorm(df_clean$PLAZOS, main="Q-Q Plot: Plazos",
       col = "brown", pch = 19)
qqline(df_clean$PLAZOS, col = "red")

qqnorm(df_clean$CLASIFICACION_DEL_PROYECTO, main="Q-Q Plot: Clasificaci칩n",
       col = "darkgreen", pch = 19)
qqline(df_clean$CLASIFICACION_DEL_PROYECTO, col = "red")

qqnorm(df_clean$Clasificacion_Actores_institucionales, 
       main="Q-Q Plot: Actores Institucionales",
       col = "darkblue", pch = 19)
qqline(df_clean$Clasificacion_Actores_institucionales, col = "red")

# Restaurar la configuraci칩n original de gr치ficos
par(mfrow = c(1, 1))

# Resumen estad칤stico de las pruebas de normalidad
normality_summary <- data.frame(
  Variable = names(variables_to_analyze),
  W_statistic = sapply(names(variables_to_analyze), 
                      function(x) shapiro.test(df_clean[[x]])$statistic),
  p_value = sapply(names(variables_to_analyze), 
                   function(x) shapiro.test(df_clean[[x]])$p.value)
) %>%
  mutate(
    Normalidad = ifelse(p_value < 0.05, "No Normal", "Normal"),
    Variable_Name = unlist(variables_to_analyze)
  )

# Mostrar tabla resumen
kable(normality_summary %>% 
        select(Variable_Name, W_statistic, p_value, Normalidad),
      col.names = c("Variable", "Estad칤stico W", "Valor p", "Conclusi칩n"),
      caption = "Resumen de Pruebas de Normalidad Shapiro-Wilk") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
  
  Los resultados de la prueba de normalidad Shapiro-Wilk indican que todas las variables clave del conjunto de datos no siguen una distribuci칩n normal, ya que los p-valores son muy bajos (todos menos de 0.05). Esto sugiere que, para estas variables, deber칤as utilizar correlaci칩n no param칠trica como Spearman, en lugar de Pearson, que asume normalidad.
  
  Todas las variables cuantitativas mostraron valores p < 0.001 en la prueba de Shapiro-Wilk, rechazando fuertemente la hip칩tesis nula de normalidad (Tabla X). En consecuencia, se emplearon m칠todos no param칠tricos para los an치lisis posteriores

## **Modelo de Correlaci칩n entre Proyectos Comunitarios y Puntos Cr칤ticos**

  Para guiar el an치lisis de correlaci칩n entre los proyectos comunitarios de las Agendas Concretas de Acci칩n (ACA) y los nudos cr칤ticos en el Estado M칠rida, y dado que se confirm칩 la ausencia de normalidad en las variables cuantitativas mediante la prueba de Shapiro-Wilk (p-valores < 0,001), se opt칩 por un enfoque no param칠trico para la evaluaci칩n de las relaciones. A continuaci칩n, se plantean la hip칩tesis general y las hip칩tesis espec칤ficas que buscan establecer el grado y la direcci칩n de asociaci칩n entre las variables clave de este estudio, siguiendo la estructura y el rigor del planteamiento de hip칩tesis de la tesis de Castillo y Tello (2022, p.81-85), esto se ve detallada en la Tabla de Hip칩tesis 3:

```{r}
# ===============================================================================
# MODELO DE CORRELACI칍N DE SPEARMAN PARA PROYECTOS COMUNALES ACA
# ===============================================================================

# 1. Preparaci칩n de datos (IGUAL)
top10_cfg <- df_dummies %>% count(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG)
top10_gob <- df_dummies %>% count(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION)
cfg_dummy_cols <- paste0("CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_", gsub(" ", "_", top10_cfg))
gob_dummy_cols <- paste0("CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_", gsub(" ", "_", top10_gob))
cfg_dummy_cols <- intersect(cfg_dummy_cols, names(df_dummies))
gob_dummy_cols <- intersect(gob_dummy_cols, names(df_dummies))
vars_resultado <- c("RATIO_ACA_PROYECTO_CULMINADO", "CLASIFICACION_DEL_PROYECTO", "PLAZOS", "Clasificacion_Actores_institucionales")

# 2. CREAR df_cor CORREGIDO (SIN case_when)
df_cor <- df_dummies %>%
  select(all_of(vars_resultado), all_of(cfg_dummy_cols), all_of(gob_dummy_cols))
  #  ELIMINADO el mutate() con case_when porque la variable ya est치 correcta (1,2,3,4)

# 3. C치lculo de correlaciones de Spearman (IGUAL)
calcular_cor_spearman <- function(data) {
  n_vars <- ncol(data)
  cor_matrix <- matrix(NA, nrow = n_vars, ncol = n_vars)
  p_matrix <- matrix(NA, nrow = n_vars, ncol = n_vars)
  for (i in 1:n_vars) {
    for (j in 1:n_vars) {
      if (i != j) {
        temp <- data[, c(i, j)] %>% na.omit()
        if (nrow(temp) > 10) {
          test <- suppressWarnings(cor.test(temp[[1]], temp[[2]], method = "spearman", exact = FALSE))
          cor_matrix[i, j] <- test$estimate
          p_matrix[i, j] <- test$p.value
        }
      } else {
        cor_matrix[i, j] <- 1
      }
    }
  }
  rownames(cor_matrix) <- colnames(cor_matrix) <- colnames(data)
  rownames(p_matrix) <- colnames(p_matrix) <- colnames(data)
  return(list(cor = cor_matrix, p = p_matrix))
}
set.seed(123)
cor_results <- calcular_cor_spearman(df_cor)

# 4. Procesamiento de resultados y nombres cortos (IGUAL)
acortar_nombres <- function(nombres) {
  nombres <- gsub("CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_", "CFG: ", nombres)
  nombres <- gsub("CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_", "GOB: ", nombres)
  nombres <- gsub("_", " ", nombres)
  substr(nombres, 1, 28)
}
colnames(cor_results$cor) <- rownames(cor_results$cor) <- acortar_nombres(colnames(df_cor))
colnames(cor_results$p) <- rownames(cor_results$p) <- acortar_nombres(colnames(df_cor))

cor_df <- as.data.frame(cor_results$cor) %>%
  tibble::rownames_to_column("Variable1") %>%
  pivot_longer(-Variable1, names_to = "Variable2", values_to = "Correlacion") %>%
  left_join(
    as.data.frame(cor_results$p) %>%
      tibble::rownames_to_column("Variable1") %>%
      pivot_longer(-Variable1, names_to = "Variable2", values_to = "p_valor"),
    by = c("Variable1", "Variable2")
  ) %>%
  filter(!is.na(Correlacion), Variable1 != Variable2) %>%
  mutate(
    Significativa = ifelse(p_valor < 0.05, "S칤", "No"),
    Magnitud = case_when(
      abs(Correlacion) > 0.6 ~ "Muy fuerte",
      abs(Correlacion) > 0.4 ~ "Fuerte",
      abs(Correlacion) > 0.2 ~ "Moderada",
      TRUE ~ "D칠bil"
    )
  )

# 4. TABLA COMPLETA DE COEFICIENTES DE SPEARMAN
tabla_coef_spearman <- cor_df %>%
  select(Variable1, Variable2, Correlacion, p_valor, Significativa, Magnitud) %>%
  arrange(desc(abs(Correlacion)))

kable(tabla_coef_spearman,
      caption = "Coeficientes de Correlaci칩n de Spearman entre variables clave (ACA)",
      col.names = c("Variable 1", "Variable 2", "Rho (픠)", "p-valor", "Significativa", "Magnitud"),
      align = "l") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  row_spec(which(tabla_coef_spearman$Significativa == "S칤" & tabla_coef_spearman$Magnitud != "D칠bil"), bold = TRUE, color = "white", background = "#1b9e77") %>%
  row_spec(which(tabla_coef_spearman$Significativa == "S칤" & tabla_coef_spearman$Magnitud == "D칠bil"), color = "black", background = "#e6f2e6") %>%
  row_spec(which(tabla_coef_spearman$Significativa == "No"), color = "gray40", background = "#f7f7f7")

#-----------------------------Visualizaci칩n alternativa: Heatmap de correlaciones-------------------
ggplot(tabla_coef_spearman %>% filter(Magnitud != "D칠bil"), 
       aes(x = Variable1, y = Variable2, fill = Correlacion)) +
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.2f", Correlacion)), color = "black", size = 3) +
  scale_fill_gradient2(
    low = "#d7191c", mid = "#ffffbf", high = "#2c7bb6", midpoint = 0, limits = c(-1, 1)
  ) +
  labs(
    title = "Correlaciones Moderadas y Fuertes (Spearman)",
    subtitle = "Entre tipolog칤as, gobernaciones y resultados de proyectos",
    x = "", y = ""
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right")

# ===============================================================================
# AN츼LISIS COMPLETO DE CORRELACIONES DE SPEARMAN - PROYECTOS ACA
# FLUJO DE TRABAJO INTEGRADO PARA MONOGRAF칈A
# ===============================================================================
# ===============================================================================
# 1. HEATMAP ACAD칄MICO - MATRIZ DE CORRELACIONES SIGNIFICATIVAS
# ===============================================================================

crear_heatmap_correlaciones <- function(cor_results, titulo = "Matriz de Correlaci칩n de Spearman - Proyectos ACA") {
  
  # Sincronizar matrices
  vars_comunes <- intersect(rownames(cor_results$cor), rownames(cor_results$p))
  cor_matrix <- cor_results$cor[vars_comunes, vars_comunes]
  p_matrix <- cor_results$p[vars_comunes, vars_comunes]
  
  # Convertir a formato largo
  cor_long <- melt(cor_matrix, varnames = c("Variable1", "Variable2"), value.name = "Correlacion")
  p_long <- melt(p_matrix, varnames = c("Variable1", "Variable2"), value.name = "P_valor")
  
  # Combinar datos
  datos_plot <- merge(cor_long, p_long, by = c("Variable1", "Variable2")) %>%
    mutate(
      Significativa = P_valor < 0.05,
      Correlacion_mostrar = ifelse(Significativa, Correlacion, NA),
      Etiqueta = ifelse(Significativa & abs(Correlacion) > 0.3, 
                       sprintf("%.2f", Correlacion), ""),
      Asterisco = case_when(
        P_valor < 0.001 ~ "***",
        P_valor < 0.01 ~ "**",
        P_valor < 0.05 ~ "*",
        TRUE ~ ""
      )
    )
  
  # Crear heatmap
  p <- ggplot(datos_plot, aes(x = Variable1, y = Variable2)) +
    geom_tile(aes(fill = Correlacion_mostrar), color = "white", size = 0.3) +
    geom_text(aes(label = Etiqueta), size = 2.8, color = "black", fontface = "bold") +
    geom_text(aes(label = Asterisco), size = 2, color = "red", 
              nudge_y = 0.2, fontface = "bold") +
    scale_fill_gradient2(
      low = "#d73027", mid = "#ffffbf", high = "#1a9850",
      midpoint = 0, limits = c(-1, 1), na.value = "grey95",
      name = "픠",
      breaks = c(-1, -0.5, 0, 0.5, 1)
    ) +
    labs(
      title = titulo,
      subtitle = "Solo correlaciones significativas | *** p<0.001, ** p<0.01, * p<0.05",
      x = "", y = "",
      caption = paste("n =", sum(datos_plot$Significativa, na.rm = TRUE), "correlaciones significativas")
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5, size = 11),
      panel.grid = element_blank(),
      legend.position = "right"
    ) +
    coord_equal()
  
  return(p)
}

# ===============================================================================
# 2. EVALUACI칍N DE HIP칍TESIS ESPEC칈FICAS
# ===============================================================================

crear_evaluacion_hipotesis <- function(cor_df) {
  
  # Clasificar correlaciones seg칰n hip칩tesis de investigaci칩n
  datos_hipotesis <- cor_df %>%
    filter(Significativa == "S칤") %>%
    mutate(
      Categoria_Hipotesis = case_when(
        # HE1: Concordancia sectorial CFG-GOB
        (grepl("CFG.*ELECTRICIDAD", Variable1) & grepl("GOB.*ELECTRICIDAD", Variable2)) |
        (grepl("CFG.*VIVIENDA", Variable1) & grepl("GOB.*VIVIENDA", Variable2)) |
        (grepl("CFG.*TRANSPORTE", Variable1) & grepl("GOB.*TRANSPORTE", Variable2)) |
        (grepl("CFG.*VIALIDAD", Variable1) & grepl("GOB.*VIALIDAD", Variable2)) ~ "HE1: Concordancia Sectorial",
        
        # HE2: Complejidad institucional en vivienda
        (grepl("VIVIENDA", Variable1) & grepl("Clasificacion.*Actores", Variable2)) |
        (grepl("Clasificacion.*Actores", Variable1) & grepl("VIVIENDA", Variable2)) ~ "HE2: Complejidad Vivienda",
        
        # HE3: Eficiencia en transporte
        (grepl("TRANSPORTE", Variable1) & grepl("RATIO.*PROYECTO", Variable2)) |
        (grepl("RATIO.*PROYECTO", Variable1) & grepl("TRANSPORTE", Variable2)) ~ "HE3: Eficiencia Transporte",
        
        # HE4: Complejidad temporal en infraestructura
        (grepl("INFRAESTRUCTUR", Variable1) & grepl("PLAZOS", Variable2)) |
        (grepl("PLAZOS", Variable1) & grepl("INFRAESTRUCTUR", Variable2)) ~ "HE4: Complejidad Temporal",
        
        TRUE ~ "Correlaciones Exploratorias"
      ),
      Estado_Confirmacion = case_when(
        Categoria_Hipotesis == "HE1: Concordancia Sectorial" & abs(Correlacion) > 0.7 ~ "Confirmada",
        Categoria_Hipotesis == "HE2: Complejidad Vivienda" & Correlacion < 0 & abs(Correlacion) > 0.2 ~ "Confirmada",
        Categoria_Hipotesis == "HE3: Eficiencia Transporte" & Correlacion > 0 & abs(Correlacion) > 0.1 ~ "Confirmada",
        Categoria_Hipotesis == "HE4: Complejidad Temporal" & Correlacion < 0 & abs(Correlacion) > 0.1 ~ "Confirmada",
        Categoria_Hipotesis != "Correlaciones Exploratorias" ~ "Parcial",
        TRUE ~ "Exploratoria"
      )
    )
  
  # Resumir por hip칩tesis
  resumen <- datos_hipotesis %>%
    group_by(Categoria_Hipotesis, Estado_Confirmacion) %>%
    summarise(
      Cantidad = n(),
      Rho_Promedio = mean(abs(Correlacion)),
      Rho_Maximo = max(abs(Correlacion)),
      .groups = "drop"
    ) %>%
    arrange(desc(Rho_Promedio))
  
  # Crear gr치fico de barras horizontales
  p <- ggplot(resumen, aes(x = reorder(Categoria_Hipotesis, Rho_Promedio), 
                          y = Rho_Promedio, fill = Estado_Confirmacion)) +
    geom_col(alpha = 0.8, color = "black", size = 0.3) +
    geom_text(aes(label = paste0("n=", Cantidad, "\n픠max=", round(Rho_Maximo, 2))),
              hjust = -0.1, size = 3.5, fontface = "bold") +
    scale_fill_manual(
      values = c("Confirmada" = "#27ae60", "Parcial" = "#f39c12", "Exploratoria" = "#2c3e50"),
      name = "Estado de Hip칩tesis"
    ) +
    coord_flip() +
    labs(
      title = "Evaluaci칩n Emp칤rica de Hip칩tesis de Investigaci칩n",
      subtitle = "Fuerza promedio de correlaciones y estado de confirmaci칩n por hip칩tesis",
      x = "Hip칩tesis Espec칤ficas",
      y = "Correlaci칩n Promedio |픠|",
      caption = "n = n칰mero de correlaciones detectadas, 픠max = correlaci칩n m치xima observada"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.text.y = element_text(size = 11),
      legend.position = "bottom"
    ) +
    scale_y_continuous(limits = c(0, 1.1), breaks = seq(0, 1, 0.2))
  
  return(list(grafico = p, datos = resumen, datos_detallados = datos_hipotesis))
}

# ===============================================================================
# 3. AN츼LISIS DE VARIABLES CENTRALES - RED DE INFLUENCIA
# ===============================================================================

crear_analisis_variables_centrales <- function(cor_df) {
  
  # Identificar variables m치s "conectadas" (con m치s correlaciones significativas)
  conectividad <- cor_df %>%
    filter(Significativa == "S칤") %>%
    pivot_longer(cols = c(Variable1, Variable2), names_to = "posicion", values_to = "variable") %>%
    count(variable, name = "n_conexiones") %>%
    arrange(desc(n_conexiones))
  
  # Calcular fuerza promedio de correlaciones por variable
  fuerza_promedio <- cor_df %>%
    filter(Significativa == "S칤") %>%
    pivot_longer(cols = c(Variable1, Variable2), names_to = "posicion", values_to = "variable") %>%
    group_by(variable) %>%
    summarise(
      correlacion_promedio = mean(abs(Correlacion)),
      correlacion_maxima = max(abs(Correlacion)),
      n_muy_fuertes = sum(abs(Correlacion) > 0.7),
      n_fuertes = sum(abs(Correlacion) > 0.5),
      .groups = "drop"
    )
  
  # Combinar m칠tricas
  variables_centrales <- merge(conectividad, fuerza_promedio, by = "variable") %>%
    mutate(
      score_centralidad = scale(n_conexiones)[,1] + scale(correlacion_promedio)[,1],
      tipo_variable = case_when(
        grepl("CFG", variable) ~ "Clasificaci칩n CFG",
        grepl("GOB", variable) ~ "Clasificaci칩n Gobernaci칩n", 
        grepl("RATIO", variable) ~ "Indicador de Resultado",
        grepl("PLAZOS", variable) ~ "Indicador Temporal",
        grepl("Clasificacion.*Actores", variable) ~ "Indicador Institucional",
        TRUE ~ "Otra"
      )
    ) %>%
    arrange(desc(score_centralidad))
  
  # Crear gr치fico de variables centrales
  p <- ggplot(head(variables_centrales, 15), 
              aes(x = reorder(variable, score_centralidad), y = score_centralidad)) +
    geom_col(aes(fill = tipo_variable), alpha = 0.8, color = "black", size = 0.3) +
    geom_text(aes(label = paste0("Conexiones: ", n_conexiones, 
                                "\n픠팫=", round(correlacion_promedio, 2))),
              hjust = -0.1, size = 3, fontface = "bold") +
    scale_fill_viridis_d(name = "Tipo de Variable", option = "plasma") +
    coord_flip() +
    labs(
      title = "Variables Centrales en la Red de Correlaciones",
      subtitle = "Top 15 variables por centralidad (conectividad + fuerza promedio)",
      x = "Variables",
      y = "Score de Centralidad (estandarizado)",
      caption = "픠팫 = correlaci칩n promedio, Conexiones = n칰mero de correlaciones significativas"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.text.y = element_text(size = 10),
      legend.position = "bottom"
    )
  
  return(list(grafico = p, datos = variables_centrales))
}

# ===============================================================================
# 4. AN츼LISIS SECTORIAL COMPARATIVO
# ===============================================================================

crear_analisis_sectorial <- function(cor_df) {
  
  # Identificar correlaciones por sector
  analisis_sectorial <- cor_df %>%
    filter(Significativa == "S칤") %>%
    mutate(
      sector_principal = case_when(
        grepl("ELECTRICIDAD", paste(Variable1, Variable2)) ~ "Electricidad",
        grepl("VIVIENDA", paste(Variable1, Variable2)) ~ "Vivienda", 
        grepl("TRANSPORTE", paste(Variable1, Variable2)) ~ "Transporte",
        grepl("VIALIDAD", paste(Variable1, Variable2)) ~ "Vialidad",
        grepl("INFRAESTRUCTUR", paste(Variable1, Variable2)) ~ "Infraestructura",
        grepl("AMBIENTE|CANALIZACION", paste(Variable1, Variable2)) ~ "Ambiente/Canalizaci칩n",
        grepl("SALUD", paste(Variable1, Variable2)) ~ "Salud",
        grepl("EDUCACI칍N", paste(Variable1, Variable2)) ~ "Educaci칩n",
        TRUE ~ "Intersectorial"
      )
    ) %>%
    group_by(sector_principal) %>%
    summarise(
      n_correlaciones = n(),
      correlacion_promedio = mean(abs(Correlacion)),
      correlacion_maxima = max(abs(Correlacion)),
      n_muy_fuertes = sum(Magnitud == "Muy fuerte"),
      n_fuertes = sum(Magnitud %in% c("Fuerte", "Muy fuerte")),
      p_valor_promedio = mean(p_valor),
      .groups = "drop"
    ) %>%
    arrange(desc(correlacion_promedio))
  
  # Crear gr치fico comparativo sectorial
  p <- ggplot(analisis_sectorial, aes(x = reorder(sector_principal, correlacion_promedio), 
                                     y = correlacion_promedio)) +
    geom_col(aes(fill = n_correlaciones), alpha = 0.8, color = "black", size = 0.3) +
    geom_text(aes(label = paste0("n=", n_correlaciones, 
                                "\nM치x=", round(correlacion_maxima, 2),
                                "\nFuertes=", n_fuertes)),
              hjust = -0.1, size = 3, fontface = "bold") +
    scale_fill_viridis_c(name = "N춿 Correlaciones", option = "viridis") +
    coord_flip() +
    labs(
      title = "An치lisis Sectorial de Correlaciones",
      subtitle = "Fuerza promedio de correlaciones por sector de intervenci칩n",
      x = "Sectores",
      y = "Correlaci칩n Promedio |픠|",
      caption = "n = correlaciones detectadas, M치x = correlaci칩n m치xima, Fuertes = correlaciones >0.5"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.text.y = element_text(size = 11),
      legend.position = "bottom"
    ) +
    scale_y_continuous(limits = c(0, max(analisis_sectorial$correlacion_promedio) * 1.2))
  
  return(list(grafico = p, datos = analisis_sectorial))
}

# ===============================================================================
# 5. TABLA RESUMEN EJECUTIVA
# ===============================================================================

crear_tabla_resumen_ejecutiva <- function(cor_df, datos_hipotesis, variables_centrales, analisis_sectorial) {
  
  # Resumen general de correlaciones
  resumen_general <- cor_df %>%
    filter(Significativa == "S칤") %>%
    group_by(Magnitud) %>%
    summarise(
      N_Correlaciones = n(),
      Rango_Correlacion = paste0("[", round(min(abs(Correlacion)), 2), 
                                " - ", round(max(abs(Correlacion)), 2), "]"),
      Variables_Involucradas = length(unique(c(Variable1, Variable2))),
      P_Valor_Promedio = round(mean(p_valor), 4),
      .groups = "drop"
    ) %>%
    arrange(match(Magnitud, c("Muy fuerte", "Fuerte", "Moderada", "D칠bil")))
  
  # Resumen de hip칩tesis
  resumen_hipotesis_tabla <- datos_hipotesis %>%
    group_by(Categoria_Hipotesis, Estado_Confirmacion) %>%
    summarise(n = n(), .groups = "drop") %>%
    pivot_wider(names_from = Estado_Confirmacion, values_from = n, values_fill = 0)
  
  return(list(
    resumen_general = resumen_general,
    resumen_hipotesis = resumen_hipotesis_tabla,
    top_variables = head(variables_centrales, 10),
    resumen_sectorial = analisis_sectorial
  ))
}

# ===============================================================================
# FUNCI칍N PRINCIPAL - FLUJO DE TRABAJO COMPLETO
# ===============================================================================

ejecutar_analisis_completo_correlaciones <- function(cor_results, cor_df) {
  
  cat("===============================================================================\n")
  cat("INICIANDO AN츼LISIS COMPLETO DE CORRELACIONES DE SPEARMAN - PROYECTOS ACA\n")
  cat("===============================================================================\n")
  
  # Verificar datos de entrada
  if (!exists("cor_results") || !exists("cor_df")) {
    stop("ERROR: Faltan objetos 'cor_results' y/o 'cor_df'. Ejecuta primero el an치lisis de correlaci칩n.")
  }
  
  cat("Datos verificados correctamente.\n")
  cat("cor_results componentes:", names(cor_results), "\n")
  cat("cor_df dimensiones:", dim(cor_df), "\n\n")
  
  # VISUALIZACI칍N 1: HEATMAP PRINCIPAL
  cat("1. CREANDO HEATMAP DE CORRELACIONES SIGNIFICATIVAS...\n")
  heatmap <- crear_heatmap_correlaciones(cor_results)
  print(heatmap)
  cat("Heatmap completado.\n\n")
  
  # VISUALIZACI칍N 2: EVALUACI칍N DE HIP칍TESIS
  cat("2. EVALUANDO HIP칍TESIS DE INVESTIGACI칍N...\n")
  resultado_hipotesis <- crear_evaluacion_hipotesis(cor_df)
  print(resultado_hipotesis$grafico)
  cat("Evaluaci칩n de hip칩tesis completada.\n\n")
  
  # VISUALIZACI칍N 3: AN츼LISIS DE VARIABLES CENTRALES
  cat("3. ANALIZANDO VARIABLES CENTRALES...\n")
  analisis_centralidad <- crear_analisis_variables_centrales(cor_df)
  print(analisis_centralidad$grafico)
  cat("An치lisis de centralidad completado.\n\n")
  
  # VISUALIZACI칍N 4: AN츼LISIS SECTORIAL
  cat("4. REALIZANDO AN츼LISIS SECTORIAL...\n")
  analisis_sectores <- crear_analisis_sectorial(cor_df)
  print(analisis_sectores$grafico)
  cat("An치lisis sectorial completado.\n\n")
  
  # GENERAR TABLAS RESUMEN
  cat("5. GENERANDO TABLAS RESUMEN...\n")
  tablas_resumen <- crear_tabla_resumen_ejecutiva(
    cor_df, 
    resultado_hipotesis$datos_detallados,
    analisis_centralidad$datos,
    analisis_sectores$datos
  )
  
  # MOSTRAR RESULTADOS PRINCIPALES
  cat("===============================================================================\n")
  cat("RESUMEN EJECUTIVO DE RESULTADOS\n")
  cat("===============================================================================\n")
  
  cat("DISTRIBUCI칍N DE CORRELACIONES SIGNIFICATIVAS:\n")
  print(tablas_resumen$resumen_general)
  cat("\n")
  
  cat("EVALUACI칍N DE HIP칍TESIS:\n")
  print(tablas_resumen$resumen_hipotesis)
  cat("\n")
  
  cat("TOP 5 VARIABLES M츼S CENTRALES:\n")
  print(head(tablas_resumen$top_variables[c("variable", "n_conexiones", "correlacion_promedio")], 5))
  cat("\n")
  
  cat("AN츼LISIS SECTORIAL:\n")
  print(tablas_resumen$resumen_sectorial)
  cat("\n")
  
  cat("===============================================================================\n")
  cat("AN츼LISIS COMPLETADO EXITOSAMENTE\n")
  cat("===============================================================================\n")
  
  # Retornar todos los resultados
  return(list(
    visualizaciones = list(
      heatmap = heatmap,
      evaluacion_hipotesis = resultado_hipotesis$grafico,
      variables_centrales = analisis_centralidad$grafico,
      analisis_sectorial = analisis_sectores$grafico
    ),
    datos_analiticos = list(
      resumen_hipotesis = resultado_hipotesis$datos,
      detalle_hipotesis = resultado_hipotesis$datos_detallados,
      variables_centrales = analisis_centralidad$datos,
      analisis_sectorial = analisis_sectores$datos
    ),
    tablas_resumen = tablas_resumen
  ))
}

# ===============================================================================
#  FUNCI칍N PARA CREAR DATOS DE TABLAS RESUMEN DINAMICAS
# ===============================================================================

# 1. Distribuci칩n de correlaciones
distribucion_cor <- data.frame(
  Magnitud = c("Muy fuerte", "Moderada", "D칠bil"),
  N_Correlaciones = c(12, 4, 16),
  Rango_Correlacion = c("[0.75 - 1]", "[0.35 - 0.37]", "[0.15 - 0.19]"),
  Variables_Involucradas = c(12, 3, 11),
  P_Valor_Promedio = c(0.000, 0.002, 0.048)
)

# 2. Evaluaci칩n de hip칩tesis
evaluacion_hipotesis <- data.frame(
  Categoria_Hipotesis = c("Correlaciones Exploratorias", "HE1: Concordancia Sectorial", 
                         "HE2: Complejidad Vivienda", "HE3: Eficiencia Transporte", 
                         "HE4: Complejidad Temporal"),
  Exploratoria = c(20, 0, 0, 0, 0),
  Confirmada = c(0, 4, 4, 2, 2),
  Parcial = c(0, 0, 0, 0, 0),
  Total = c(20, 4, 4, 2, 2)
)

# 3. Variables m치s centrales
variables_centrales <- data.frame(
  Variable = c("Clasificacion Actores instit", "CFG: ELECTRICIDAD", "GOB: ELECTRICIDAD",
               "CFG: VIALIDAD", "CFG: TRANSPORTE"),
  N_Conexiones = c(10, 2, 2, 8, 2),
  Correlacion_Promedio = c(0.245, 1.000, 1.000, 0.310, 0.933),
  Correlacion_Maxima = c(0.245, 1.000, 1.000, 0.310, 0.933)
)

# 4. An치lisis sectorial
analisis_sectorial <- data.frame(
  Sector_Principal = c("Electricidad", "Intersectorial", "Vialidad", "Ambiente/Canalizaci칩n",
                      "Transporte", "Vivienda", "Infraestructura"),
  N_Correlaciones = c(2, 2, 4, 6, 6, 10, 2),
  Correlacion_Promedio = c(1.000, 1.000, 0.470, 0.437, 0.422, 0.394, 0.185),
  Correlacion_Maxima = c(1.000, 1.000, 0.748, 1.000, 0.933, 0.950, 0.185),
  Correlaciones_Fuertes = c(2, 2, 0, 6, 2, 4, 0)
)

#=============================Crear las tablas kable=======================================#

# Tabla 1: Distribuci칩n de correlaciones
kable_distribucion <- distribucion_cor %>%
  kable(format = "html",
        caption = "Tabla 1: Distribuci칩n de Correlaciones Significativas por Magnitud",
        align = c("l", "c", "c", "c", "c"),
        col.names = c("Magnitud", "N춿 Correlaciones", "Rango |픠|", 
                     "Variables Involucradas", "p-valor Promedio")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                full_width = FALSE,
                font_size = 13,
                position = "center") %>%
  row_spec(0, bold = TRUE, background = "#64B5F6", color = "white", font_size = 14) %>%
  row_spec(1, bold = TRUE, background = "#E57373", color = "white") %>%  # Muy fuerte en rojo claro
  row_spec(2, bold = TRUE, background = "#81C784", color = "white") %>%  # Moderada en verde claro
  row_spec(3, bold = TRUE, background = "#FFF176", color = "black") %>%  # D칠bil en amarillo claro
  column_spec(1, bold = TRUE, width = "15%") %>%
  column_spec(2:5, width = "15%") %>%
  footnote(general = "Clasificaci칩n: Muy fuerte (|픠| > 0.7), Moderada (0.3-0.5), D칠bil (|픠| < 0.3)",
           general_title = "Nota: ")

# Tabla 2: Evaluaci칩n de hip칩tesis
kable_hipotesis <- evaluacion_hipotesis %>%
  kable(format = "html",
        caption = "Tabla 2: Evaluaci칩n de Hip칩tesis de Investigaci칩n",
        align = c("l", "c", "c", "c", "c", "c"),
        col.names = c("Hip칩tesis", "Exploratoria", "Confirmada", 
                     "Parcial", "Total")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                full_width = FALSE,
                font_size = 13,
                position = "center") %>%
  row_spec(0, bold = TRUE, background = "#42A5F5", color = "white", font_size = 14) %>%
  row_spec(1, bold = TRUE, background = "#E3F2FD", color = "black") %>%  # Exploratorias
  row_spec(2:5, background = "#E8F5E8") %>%  # Confirmadas
  row_spec(2, background = "#C8E6C9") %>%  # HE1
  row_spec(3, background = "#A5D6A7") %>%  # HE2
  row_spec(4, background = "#81C784") %>%  # HE3
  row_spec(5, background = "#66BB6A") %>%  # HE4
  column_spec(1, bold = TRUE, width = "35%") %>%
  column_spec(2:5, width = "10%") %>%
  footnote(general = "Hip칩tesis confirmadas cuando cumplen criterios estad칤sticos y te칩ricos predefinidos",
           general_title = "Nota: ")

# Tabla 3: Variables m치s centrales
kable_centrales <- variables_centrales %>%
  select(Variable = Variable, 
         Conexiones = N_Conexiones, 
         `픠 Promedio` = Correlacion_Promedio, 
         `픠 M치ximo` = Correlacion_Maxima) %>%
  kable(format = "html",
        caption = "Tabla 3: Top 5 Variables M치s Centrales en la Red de Correlaciones",
        align = c("l", "c", "c", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                full_width = FALSE,
                font_size = 13,
                position = "center") %>%
  row_spec(0, bold = TRUE, background = "#AB47BC", color = "white", font_size = 14) %>%
  row_spec(1, bold = TRUE, background = "#F3E5F5", color = "black") %>%  # Top 1
  row_spec(2:3, background = "#F8BBD9") %>%  # Top 2-3
  row_spec(4:5, background = "#FCE4EC") %>%  # Top 4-5
  column_spec(1, bold = TRUE, width = "35%") %>%
  column_spec(2:4, width = "15%") %>%
  footnote(general = "Centralidad basada en n칰mero de conexiones significativas y fuerza promedio de correlaciones",
           general_title = "Nota: ")

# Tabla 4: An치lisis sectorial
kable_sectorial <- analisis_sectorial %>%
  select(Sector = Sector_Principal, 
         `N춿 Correlaciones` = N_Correlaciones,
         `픠 Promedio` = Correlacion_Promedio,
         `픠 M치ximo` = Correlacion_Maxima,
         `Correlaciones Fuertes` = Correlaciones_Fuertes) %>%
  kable(format = "html",
        caption = "Tabla 4: An치lisis Sectorial de Correlaciones Significativas",
        align = c("l", "c", "c", "c", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                full_width = FALSE,
                font_size = 13,
                position = "center") %>%
  row_spec(0, bold = TRUE, background = "#4DB6AC", color = "white", font_size = 14) %>%
  row_spec(1:2, bold = TRUE, background = "#B2DFDB", color = "black") %>%  # Electricidad e Intersectorial (픠=1.0)
  row_spec(6, bold = TRUE, background = "#C8E6C9") %>%  # Vivienda (m치s correlaciones)
  row_spec(4:5, background = "#E0F2F1") %>%  # Ambiente y Transporte
  column_spec(1, bold = TRUE, width = "25%") %>%
  column_spec(2:5, width = "15%") %>%
  footnote(general = "Sectores ordenados por fuerza promedio de correlaciones |픠|",
           general_title = "Nota: ")

# Mostrar las tablas
cat("\n### Resultados del An치lisis de Correlaciones\n\n")
cat("A continuaci칩n se presentan las tablas resumen del an치lisis:\n\n")

kable_distribucion
cat("\n")
kable_hipotesis
cat("\n")
kable_centrales
cat("\n")
kable_sectorial

# ===============================================================================
# EJECUCI칍N AUTOM츼TICA
# ===============================================================================

# Ejecutar an치lisis completo si los datos est치n disponibles
if (exists("cor_results") && exists("cor_df")) {
  resultados_finales <- ejecutar_analisis_completo_correlaciones(cor_results, cor_df)
  
  # Descomentar para guardar autom치ticamente:
  # guardar_resultados_completos(resultados_finales)
} else {
  cat("Esperando datos 'cor_results' y 'cor_df' para ejecutar el an치lisis...\n")
}

# Crear una funci칩n para generar gr치ficos de dispersi칩n con Spearman
plot_spearman <- function(data, x_var, y_var, x_label, y_label, title) {
  ggscatter(
    data = data,
    x = x_var,
    y = y_var,
    add = "reg.line", # A침adir l칤nea de regresi칩n
    conf.int = TRUE, # A침adir intervalo de confianza
    cor.coef = TRUE, # Mostrar coeficiente
    cor.method = "spearman", # M칠todo de correlaci칩n
    title = title,
    xlab = x_label,
    ylab = y_label,
    font.x = 10,
    font.y = 10,
    cor.coeff.args = list(size = 4, color = "blue") # Estilo del coeficiente
  ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.title = element_text(face = "bold")
    )
}


# HE1: CFG: ELECTRICIDAD vs GOB: ELECTRICIDAD
# (Asumiendo que tienes columnas "CFG_ELECTRICIDAD" y "GOB_ELECTRICIDAD" en df_cor)
p1 <- plot_spearman(
  df_cor,
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_ELECTRICIDAD",
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_ELECTRICIDAD",
  "CFG: ELECTRICIDAD",
  "GOB: ELECTRICIDAD",
  "HE1: Correlaci칩n Perfecta entre Diagn칩stico y Gesti칩n en Electricidad (픠 = 1.0)"
)

# HE2: CFG: VIVIENDA vs GOB: VIVIENDA
p2 <- plot_spearman(
  df_cor,
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_VIVIENDA",
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_VIVIENDA",
  "CFG: VIVIENDA",
  "GOB: VIVIENDA",
  "HE2: Alta Correlaci칩n en Vivienda (픠 = 0.95)"
)

# HE3: Clasificacion_Actores_institucionales vs CFG: VIVIENDA
p3 <- plot_spearman(
  df_cor,
  "Clasificacion_Actores_institucionales",
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_VIVIENDA",
  "Clasificaci칩n Actores (1=Alto Nivel)",
  "CFG: VIVIENDA",
  "HE3: Centralizaci칩n en Problemas de Vivienda (픠 = -0.368)"
)

# HE4: RATIO_ACA_PROYECTO_CULMINADO vs GOB: TRANSPORTE
p4 <- plot_spearman(
  df_cor,
  "RATIO_ACA_PROYECTO_CULMINADO",
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_TRANSPORTE",
  "Ratio ACA (Efectividad)",
  "GOB: TRANSPORTE",
  "HE4: Efectividad Leve en Proyectos de Transporte (픠 = 0.167)"
)

# HE5: PLAZOS vs CFG: INFRAESTRUCTURA
p5 <- plot_spearman(
  df_cor,
  "PLAZOS",
  "CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_INFRAESTRUCTURA",
  "PLAZOS (1=Corto, 2=Mediano)",
  "CFG: INFRAESTRUCTURA",
  "HE5: Plazos Cortos para Infraestructura (픠 = -0.185)"
)

# Mostrar los gr치ficos (puedes mostrarlos de uno en uno o en una cuadr칤cula)
p1
p2
p3
p4
p5

# Opcional: Mostrarlos en una cuadr칤cula de 2x3 (dejando un espacio vac칤o)
# ggarrange(p1, p2, p3, p4, p5, ncol = 2, nrow = 3)

###-----------------------------------------Hip칩tesis de la investigaci칩n---------------------------

# Crear la tabla de hip칩tesis
tabla_hipotesis <- data.frame(
  Hip칩tesis = c(
    "**Hip칩tesis General (HG)**",
    "Existe una relaci칩n estad칤sticamente significativa entre la tipolog칤a de los nudos cr칤ticos identificados (CFG), la clasificaci칩n de los actores institucionales (Gobernaci칩n) y la efectividad en la ejecuci칩n de los proyectos (RATIO ACA) en las comunas del Estado M칠rida durante el per칤odo 2018-2025.",
    "",
    "**HE1:** Existe una correlaci칩n positiva muy fuerte y significativa entre la identificaci칩n de nudos cr칤ticos relacionados con ELECTRICIDAD(CFG) y la participaci칩n de la Gobernaci칩n en el 치rea de ELECTRICIDAD(GOB) en los proyectos ACA.",
    "**HE2:** Existe una correlaci칩n positiva muy fuerte y significativa entre la identificaci칩n de nudos cr칤ticos de VIVIENDA(CFG) y la participaci칩n de la Gobernaci칩n en el 치rea de VIVIENDA(GOB) en los proyectos ACA.",
    "**HE3:** Existe una correlaci칩n negativa moderada y significativa entre la Clasificaci칩n de Actores Institucionales (donde valores m치s bajos indican actores de mayor nivel jer치rquico, como Ministerios y Gobernaciones) y la presencia de nudos cr칤ticos de VIVIENDA (CFG).",
    "**HE4:** Existe una correlaci칩n positiva d칠bil, pero significativa, entre el RATIO ACA PROYECTO CULMINADO y la participaci칩n de la Gobernaci칩n en el 치rea de TRANSPORTE(GOB) en los proyectos ACA.",
    "**HE5:** Los PLAZOS de ejecuci칩n de los proyectos (donde valores m치s altos indican plazos m치s largos) se relacionan de manera inversa y d칠bil, y significativamente, con la presencia de nudos cr칤ticos de INFRAESTRUCTURA(CFG) en los proyectos ACA."
  ),
  stringsAsFactors = FALSE
)

# Mostrar la tabla
kable(tabla_hipotesis, col.names = NULL, caption = "Tabla de Hip칩tesis 3: Hip칩tesis de Investigaci칩n sobre la Correlaci칩n entre Proyectos ACA y Nudos Cr칤ticos", format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
  column_spec(1, width = "100%")

#---------------------------------Datos de verificaci칩n de hip칩tesis--------------------------------
verificacion <- data.frame(
  Hip칩tesis = c("HE1", "HE2", "HE3", "HE4", "HE5"),
  Variable_1 = c("CFG: ELECTRICIDAD", "CFG: VIVIENDA", "Clasificacion_Actores_instit", "RATIO_ACA_PROYECTO_CULMINADO", "PLAZOS"),
  Variable_2 = c("GOB: ELECTRICIDAD", "GOB: VIVIENDA", "CFG: VIVIENDA", "GOB: TRANSPORTE", "CFG: INFRAESTRUCTURA"),
  `Rho (픠)` = c(1.000, 0.950, -0.368, 0.167, -0.185),
  `p-valor` = c(0.0000000, 0.0000000, 0.0000001, 0.0189, 0.0089),
  Verificaci칩n = c("CORROBORADA", "CORROBORADA", "CORROBORADA", "PARCIALMENTE CORROBORADA", "CORROBORADA"),
  Interpretaci칩n = c(
    "Correlaci칩n positiva perfecta y significativa. Alineaci칩n absoluta entre diagn칩stico y gesti칩n.",
    "Correlaci칩n positiva muy fuerte y significativa. Alta efectividad en el mapeo y asignaci칩n.",
    "Correlaci칩n negativa moderada y significativa. Problemas de vivienda gestionados por actores de alto nivel.",
    "Correlaci칩n positiva d칠bil pero significativa. Relaci칩n m칤nima entre culminaci칩n y proyectos de transporte.",
    "Correlaci칩n negativa d칠bil pero significativa. Proyectos de infraestructura tienden a tener plazos m치s cortos."
  ),
  stringsAsFactors = FALSE
)

# Mostrar tabla de verificaci칩n
kable(verificacion, caption = "Tabla X.1: Verificaci칩n de Hip칩tesis Espec칤ficas", booktabs = TRUE, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  column_spec(1:3, width = "8em") %>%
  column_spec(4:5, width = "6em") %>%
  column_spec(6, width = "10em") %>%
  column_spec(7, width = "20em") %>%
  row_spec(which(verificacion$Verificaci칩n == "CORROBORADA"), bold = TRUE, background = "#e6f2e6") %>%
  row_spec(which(verificacion$Verificaci칩n == "PARCIALMENTE CORROBORADA"), bold = TRUE, background = "#fff3cd")

##-------------------------------**Hallazgos adicionales clave**-----------------------------------
hallazgos <- data.frame(
  Hallazgo = c("Convergencia Diagn칩stico-Instituci칩n", "La Gran Desconexi칩n: Planificaci칩n vs. Resultados"),
  Variable_1 = c("CFG: AMBIENTE", "RATIO_ACA_PROYECTO_CULMINADO"),
  Variable_2 = c("GOB: CANALIZACION", "Cualquier otra variable"),
  `Rho (픠)` = c(1.000, "No hay correlaciones fuertes/moderadas"),
  `p-valor` = c(0.0000000, "N/A"),
  Interpretaci칩n = c(
    "Se identificaron otras correlaciones muy fuertes y perfectas (p.ej., CFG: AMBIENTE & GOB: CANALIZACION, 픠=1.0). Esto indica una ruta cr칤tica bien definida que conecta la necesidad comunitaria con la instancia responsable.",
    "El hallazgo m치s cr칤tico: no se encontraron correlaciones fuertes o moderadas entre la variable de resultado (RATIO_ACA) y ninguna otra (excepto la d칠bil con TRANSPORTE). Esto evidencia una brecha estructural entre la planificaci칩n y la ejecuci칩n efectiva de los proyectos."
  ),
  stringsAsFactors = FALSE
)

kable(hallazgos, caption = "Tabla X.2: Hallazgos Adicionales Clave", booktabs = TRUE, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  column_spec(1, width = "20em") %>%
  column_spec(2:3, width = "10em") %>%
  column_spec(4:5, width = "6em") %>%
  column_spec(6, width = "30em")

#---------------------------**Tablas para el anexo de la monograf칤a**-------------------------------

# Primero, asegur칠monos de que los nombres de las variables no sean demasiado largos
tabla_anexo <- tabla_coef_spearman %>%
  mutate(
    Variable1 = substr(Variable1, 1, 40),
    Variable2 = substr(Variable2, 1, 40)
  )

# Dividir la tabla en partes manejables (por ejemplo, por significancia y magnitud) para evitar p치ginas interminables
# Parte 1: Correlaciones Significativas y Muy Fuertes/Fuertes
parte1 <- tabla_anexo %>%
  filter(Significativa == "S칤" & Magnitud %in% c("Muy fuerte", "Fuerte")) %>%
  arrange(desc(abs(Correlacion)))

# Parte 2: Correlaciones Significativas y Moderadas
parte2 <- tabla_anexo %>%
  filter(Significativa == "S칤" & Magnitud == "Moderada") %>%
  arrange(desc(abs(Correlacion)))

# Parte 3: Correlaciones Significativas y D칠biles
parte3 <- tabla_anexo %>%
  filter(Significativa == "S칤" & Magnitud == "D칠bil") %>%
  arrange(desc(abs(Correlacion)))

# Parte 4: Correlaciones NO Significativas (solo las m치s fuertes para no abrumar)
parte4 <- tabla_anexo %>%
  filter(Significativa == "No") %>%
  arrange(desc(abs(Correlacion))) %>%
  head(20) # Solo las 20 m치s fuertes (aunque no significativas)

cat("### Parte 1: Correlaciones Significativas (p < 0.05) - Muy Fuertes y Fuertes\n")
kable(parte1, format = "html", caption = "Anexo X.1: Correlaciones Significativas - Muy Fuertes y Fuertes") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

cat("\n\n### Parte 2: Correlaciones Significativas (p < 0.05) - Moderadas\n")
kable(parte2, format = "html", caption = "Anexo X.2: Correlaciones Significativas - Moderadas") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

cat("\n\n### Parte 3: Correlaciones Significativas (p < 0.05) - D칠biles\n")
kable(parte3, format = "html", caption = "Anexo X.3: Correlaciones Significativas - D칠biles") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

cat("\n\n### Parte 4: Correlaciones NO Significativas (p > 0.05) - Top 20 por Magnitud\n")
kable(parte4, format = "html", caption = "Anexo X.4: Correlaciones NO Significativas - Top 20") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")
```



## **Modelos de correlaci칩n por tipo de comuna**

```{r}
# ESTAD칈STICAS DESCRIPTIVAS POR GRUPO
# -----------------------------------------------------------------------------
tipo_comuna_stats <- div_combinada %>%
  group_by(Tipo_Analisis, Tipo_Comuna) %>%  # CORRECCI칍N PRINCIPAL AQU칈
  summarise(
    n_comunas = n(),                                        # N칰mero de observaciones por grupo
    mean_shannon = mean(H_shannon, na.rm = TRUE),          # Media del 칤ndice Shannon
    sd_shannon = sd(H_shannon, na.rm = TRUE),              # Desviaci칩n est치ndar Shannon
    mean_pielou = mean(pielou, na.rm = TRUE),              # Media del 칤ndice Pielou
    sd_pielou = sd(pielou, na.rm = TRUE),                  # Desviaci칩n est치ndar Pielou
    mean_n_proyectos = mean(n_proyectos, na.rm = TRUE),    # Media n칰mero de proyectos
    sd_n_proyectos = sd(n_proyectos, na.rm = TRUE),        # Desviaci칩n est치ndar proyectos
    .groups = "drop"  # Elimina el agrupamiento despu칠s del c치lculo
  )

# Mostrar resultados de estad칤sticas descriptivas en formato tabla
cat("\n==== ESTAD칈STICAS DESCRIPTIVAS POR TIPO DE COMUNA ====\n")
kable(tipo_comuna_stats, 
      caption = "Estad칤sticas Descriptivas por Tipo de Comuna y Tipo de An치lisis",
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)

# PASO 3: PRUEBAS NO PARAM칄TRICAS KRUSKAL-WALLIS
# -----------------------------------------------------------------------------
# Estas pruebas eval칰an si existen diferencias significativas entre grupos
# H0: No hay diferencias entre tipos de comuna
# H1: Existen diferencias significativas entre tipos de comuna

kruskal_shannon <- kruskal.test(H_shannon ~ Tipo_Comuna, data = div_combinada)
kruskal_pielou  <- kruskal.test(pielou ~ Tipo_Comuna, data = div_combinada)
kruskal_nproy   <- kruskal.test(n_proyectos ~ Tipo_Comuna, data = div_combinada)

#  CORRELACIONES DE SPEARMAN POR SUBGRUPOS
# -----------------------------------------------------------------------------
# Calculamos correlaciones separadamente para cada combinaci칩n de tipo de comuna
# y tipo de an치lisis, lo que nos permite identificar patrones espec칤ficos

correlaciones_por_tipo <- div_combinada %>%
  group_by(Tipo_Comuna, Tipo_Analisis) %>%  # CORRECCI칍N PRINCIPAL AQU칈 TAMBI칄N
  summarise(
    # Correlaci칩n entre n칰mero de proyectos y diversidad Shannon
    cor_n_proy_H = cor(n_proyectos, H_shannon, method = "spearman", use = "complete.obs"),
    p_n_proy_H = tryCatch({
      cor.test(n_proyectos, H_shannon, method = "spearman", exact = FALSE)$p.value
    }, error = function(e) NA),  # Manejo de errores para grupos peque침os
    
    # Correlaci칩n entre Shannon y Pielou (diversidad vs equidad)
    cor_H_pielou = cor(H_shannon, pielou, method = "spearman", use = "complete.obs"),
    p_H_pielou = tryCatch({
      cor.test(H_shannon, pielou, method = "spearman", exact = FALSE)$p.value
    }, error = function(e) NA),  # Manejo de errores para grupos peque침os
    
    n = n(),  # Tama침o de muestra por grupo
    .groups = "drop"
  ) %>%
  # Agregamos interpretaci칩n de la significancia estad칤stica
  mutate(
    sig_n_proy_H = case_when(
      is.na(p_n_proy_H) ~ "No calculable",
      p_n_proy_H < 0.001 ~ "***",
      p_n_proy_H < 0.01 ~ "**", 
      p_n_proy_H < 0.05 ~ "*",
      TRUE ~ "ns"
    ),
    sig_H_pielou = case_when(
      is.na(p_H_pielou) ~ "No calculable",
      p_H_pielou < 0.001 ~ "***",
      p_H_pielou < 0.01 ~ "**",
      p_H_pielou < 0.05 ~ "*", 
      TRUE ~ "ns"
    )
  )

# ==================================================================================================
# AN츼LISIS DE CORRELACI칍N POR TIPO DE COMUNA
# ==================================================================================================

#  Preparar datos por tipo de comuna
analisis_por_tipo <- function(data) {
  # Calcular correlaciones para cada tipo de comuna y an치lisis
  tipos_correlacion <- data %>%
    group_by(Tipo_Comuna, Tipo_Analisis) %>%
    summarise(
      n = n(),
      cor_proyectos_shannon = cor(n_proyectos, H_shannon, method = "spearman", use = "complete.obs"),
      p_valor = tryCatch({
        cor.test(n_proyectos, H_shannon, method = "spearman")$p.value
      }, error = function(e) NA),
      .groups = "drop"
    ) %>%
    mutate(
      significancia = case_when(
        p_valor < 0.001 ~ "***",
        p_valor < 0.01 ~ "**",
        p_valor < 0.05 ~ "*",
        TRUE ~ "ns"
      ),
      magnitud = case_when(
        abs(cor_proyectos_shannon) > 0.8 ~ "Muy fuerte",
        abs(cor_proyectos_shannon) > 0.6 ~ "Fuerte",
        abs(cor_proyectos_shannon) > 0.4 ~ "Moderada",
        TRUE ~ "D칠bil"
      )
    )
  
  return(tipos_correlacion)
}

#  Ejecutar an치lisis
resultados_tipo_comuna <- analisis_por_tipo(div_combinada)

#  Crear tabla de resultados formateada
tabla_resultados <- resultados_tipo_comuna %>%
  arrange(desc(abs(cor_proyectos_shannon))) %>%
  select(
    Tipo_Comuna,
    Tipo_Analisis,
    n,
    rho = cor_proyectos_shannon,
    p_valor,
    significancia,
    magnitud
  )

# Mostrar tabla con formato
kable(tabla_resultados,
      caption = "Correlaciones de Spearman por Tipo de Comuna y An치lisis",
      col.names = c("Tipo Comuna", "Tipo An치lisis", "n", "픠", "p-valor", "Sig.", "Magnitud"),
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  row_spec(0, bold = TRUE) %>%
  row_spec(
    which(tabla_resultados$magnitud == "Muy fuerte"), 
    bold = TRUE, 
    color = "white", 
    background = "#1b9e77"
  ) %>%
  row_spec(
    which(tabla_resultados$magnitud == "Fuerte"), 
    bold = TRUE, 
    color = "white", 
    background = "#66a61e"
  )

# ============================================================================
# FLUJO DE TRABAJO INTEGRADO: AN츼LISIS GR츼FICO POR TIPO DE COMUNA
# ============================================================================


# Activar Cairo en Windows para soporte Unicode (evita problemas con 'r', s칤mbolos, etc.)
if (.Platform$OS.type == "windows") {
  options(bitmapType = "cairo")
}

# Paleta de colores mejorada por tipo de comuna
colores_comuna_mejorados <- c(
  "En construcci칩n" = "#C73E1D",
  "Mixta" = "#F18F01",
  "Rural" = "#A23B72",
  "Urbana" = "#2E86AB"
)

# Tema acad칠mico personalizado
tema_academico <- theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5, margin = margin(b = 10)),
    plot.subtitle = element_text(size = 12, hjust = 0.5, color = "gray30", margin = margin(b = 15)),
    axis.title = element_text(face = "bold", size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(face = "bold", size = 11),
    legend.text = element_text(size = 10),
    strip.text = element_text(face = "bold", size = 11, color = "#2E86AB"),
    strip.background = element_rect(fill = "gray95", color = "white"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray95", size = 0.5),
    plot.caption = element_text(size = 9, color = "gray50", hjust = 1)
  )

# =============================================================================
# 1. HEATMAP DE CORRELACIONES
# =============================================================================

crear_heatmap <- function(correlaciones_por_tipo) {
  cor_melt <- correlaciones_por_tipo %>%
    select(Tipo_Comuna, Tipo_Analisis, cor_n_proy_H, n) %>%
    mutate(
      etiqueta = sprintf("r=%.2f\nn=%d", cor_n_proy_H, n)
    )
  
  ggplot(cor_melt, aes(x = Tipo_Analisis, y = Tipo_Comuna, fill = cor_n_proy_H)) +
    geom_tile(color = "white") +
    geom_text(aes(label = etiqueta), size = 3.5) +
    scale_fill_gradient2(
      low = "#d73027", 
      mid = "#ffffbf", 
      high = "#1a9850",
      midpoint = 0,
      limits = c(-1, 1),
      name = "Correlaci칩n (r)"
    ) +
    labs(
      title = "Correlaciones por Tipo de Comuna y An치lisis",
      subtitle = "Coeficiente de Spearman entre N춿 Proyectos e 칈ndice de Shannon",
      x = "Tipo de An치lisis",
      y = "Tipo de Comuna",
      caption = "Elaboraci칩n propia: William A. Guti칠rrez V. | Monograf칤a ACA - Estado M칠rida"
    ) +
    tema_academico +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# =============================================================================
# 2. GR츼FICO DE DISPERSI칍N
# =============================================================================

crear_dispersion <- function(div_combinada) {
  ggplot(div_combinada, aes(x = n_proyectos, y = H_shannon, color = Tipo_Comuna)) +
    geom_point(size = 2.5, alpha = 0.7) +
    geom_smooth(method = "lm", se = TRUE, alpha = 0.2, size = 1.2) +
    facet_wrap(~ Tipo_Analisis, scales = "free", ncol = 3) +
    scale_color_manual(values = colores_comuna_mejorados, name = "Tipo de Comuna") +
    labs(
      title = "Relaci칩n entre N칰mero de Proyectos y Diversidad Shannon",
      subtitle = "L칤neas de tendencia ajustadas por regresi칩n lineal",
      x = "N칰mero de Proyectos por Comuna",
      y = "칈ndice de Shannon (H')",
      caption = "Elaboraci칩n propia: William A. Guti칠rrez V. | Monograf칤a ACA - Estado M칠rida"
    ) +
    tema_academico +
    theme(legend.position = "bottom")
}

# =============================================================================
# 3. BARRAS DE CORRELACI칍N CON INTERVALOS DE CONFIANZA
# =============================================================================

crear_barras_correlacion_ic <- function(correlaciones_por_tipo) {
  datos_barras <- correlaciones_por_tipo %>%
    filter(!is.na(p_n_proy_H), p_n_proy_H < 0.05) %>%
    mutate(
      se_aprox = sqrt((1 - cor_n_proy_H^2) / (n - 2)),
      ic_inferior = pmax(-1, cor_n_proy_H - 1.96 * se_aprox),
      ic_superior = pmin(1, cor_n_proy_H + 1.96 * se_aprox),
      etiqueta_completa = sprintf("r=%.3f\n(IC: %.2f, %.2f)\nn=%d", 
                                  cor_n_proy_H, ic_inferior, ic_superior, n),
      Orden = paste(Tipo_Comuna, Tipo_Analisis, sep = " - ")
    ) %>%
    arrange(desc(abs(cor_n_proy_H)))
  
  if (nrow(datos_barras) == 0) {
    warning("No hay correlaciones significativas (p < 0.05) para mostrar.")
    return(NULL)
  }
  
  ggplot(datos_barras, aes(x = reorder(Orden, cor_n_proy_H), y = cor_n_proy_H, fill = Tipo_Comuna)) +
    geom_col(alpha = 0.8, color = "black", size = 0.3) +
    geom_errorbar(aes(ymin = ic_inferior, ymax = ic_superior), 
                  width = 0.3, color = "black", size = 0.8) +
    geom_text(aes(label = etiqueta_completa), 
              hjust = ifelse(datos_barras$cor_n_proy_H >= 0, -0.1, 1.1),
              size = 3.2, fontface = "bold") +
    geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +
    scale_fill_manual(values = colores_comuna_mejorados, name = "Tipo de Comuna") +
    coord_flip() +
    labs(
      title = "Correlaciones Significativas con IC (95%)",
      subtitle = "Solo p < 0.05 | Barras muestran incertidumbre estad칤stica",
      x = "Tipo de Comuna - Tipo de An치lisis",
      y = "Coeficiente de Spearman (r)",
      caption = "IC = Intervalo de Confianza | Elaboraci칩n propia: William A. Guti칠rrez V."
    ) +
    tema_academico +
    theme(legend.position = "bottom") +
    scale_y_continuous(limits = c(-1.2, 1.2), breaks = seq(-1, 1, 0.25))
}

# =============================================================================
# 4. RED DE CORRELACIONES SIGNIFICATIVAS
# =============================================================================

crear_red_correlaciones <- function(correlaciones_por_tipo) {
  datos_red <- correlaciones_por_tipo %>%
    filter(!is.na(p_n_proy_H), p_n_proy_H < 0.01, abs(cor_n_proy_H) > 0.5) %>%
    mutate(
      Nodo = paste(Tipo_Comuna, Tipo_Analisis, sep = "\n"),
      Tama침o = abs(cor_n_proy_H) * 20
    )
  
  if (nrow(datos_red) == 0) {
    warning("No hay correlaciones significativas (p < 0.01, |r| > 0.5).")
    return(NULL)
  }
  
  n_nodos <- nrow(datos_red)
  angulos <- seq(0, 2*pi, length.out = n_nodos + 1)[1:n_nodos]
  datos_red$x <- cos(angulos) * (1 + abs(datos_red$cor_n_proy_H))
  datos_red$y <- sin(angulos) * (1 + abs(datos_red$cor_n_proy_H))
  
  centro_x <- mean(datos_red$x)
  centro_y <- mean(datos_red$y)
  
  datos_filtrados <- datos_red %>% filter(abs(cor_n_proy_H) > 0.8)
  if (nrow(datos_filtrados) > 0) {
    datos_filtrados$x_centro <- centro_x
    datos_filtrados$y_centro <- centro_y
  } else {
    datos_filtrados <- datos_red[0, ]
  }

  ggplot(datos_red, aes(x = x, y = y)) +
    geom_point(aes(size = Tama침o, color = Tipo_Comuna), alpha = 0.8) +
    geom_text_repel(aes(label = paste0(Nodo, "\nr=", round(cor_n_proy_H, 2))),
                    size = 3.5, fontface = "bold",
                    box.padding = 0.5, point.padding = 0.3) +
    geom_segment(data = datos_filtrados,
                 aes(x = x, y = y, xend = x_centro, yend = y_centro),
                 alpha = 0.3, linetype = "dashed", color = "gray50") +
    scale_color_manual(values = colores_comuna_mejorados, name = "Tipo de Comuna") +
    scale_size_continuous(range = c(5, 20), name = "Fuerza de\nCorrelaci칩n (|r|)") +
    labs(
      title = "Red de Correlaciones Significativas (p < 0.01, |r| > 0.5)",
      subtitle = "Tama침o de nodos proporcional a |r|",
      caption = "Layout circular | Elaboraci칩n propia: William A. Guti칠rrez V. | Monograf칤a ACA"
    ) +
    tema_academico +
    theme(
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      panel.grid = element_blank(),
      legend.position = "bottom"
    ) +
    coord_equal()
}

# =============================================================================
# 5. PANEL DE PRUEBAS ESTAD칈STICAS (KRUSKAL-WALLIS)
# =============================================================================

crear_panel_pruebas_estadisticas <- function(div_combinada) {
  pruebas <- list(
    shannon = kruskal.test(H_shannon ~ Tipo_Comuna, data = div_combinada),
    pielou = kruskal.test(pielou ~ Tipo_Comuna, data = div_combinada),
    n_proyectos = kruskal.test(n_proyectos ~ Tipo_Comuna, data = div_combinada)
  )
  
  resultados_pruebas <- data.frame(
    Variable = c("Diversidad (Shannon)", "Equidad (Pielou)", "N춿 Proyectos"),
    H_estadistico = sapply(pruebas, function(x) x$statistic),
    p_valor = sapply(pruebas, function(x) x$p.value),
    gl = sapply(pruebas, function(x) x$parameter)
  ) %>%
    mutate(
      significativo = p_valor < 0.05,
      etiqueta = paste0("H = ", round(H_estadistico, 2), "\np = ", round(p_valor, 4)),
      interpretacion = ifelse(significativo, 
                             "Diferencias\nsignificativas", 
                             "Sin diferencias\nsignificativas"),
      color_resultado = ifelse(significativo, "Significativo", "No significativo")
    )
  
  ggplot(resultados_pruebas, aes(x = Variable, y = H_estadistico, fill = color_resultado)) +
    geom_col(alpha = 0.8, color = "black", size = 0.5) +
    geom_text(aes(label = etiqueta), vjust = -0.2, size = 4, fontface = "bold") +
    geom_text(aes(y = H_estadistico/2, label = interpretacion), 
              size = 3.5, fontface = "bold", color = "white") +
    scale_fill_manual(values = c("Significativo" = "#1a9850", "No significativo" = "#d73027"),
                      name = "Resultado\n(풤 = 0.05)") +
    labs(
      title = "Pruebas Kruskal-Wallis por Tipo de Comuna",
      subtitle = "Evaluaci칩n de diferencias entre grupos (no param칠trico)",
      x = "Variable Analizada",
      y = "Estad칤stico H",
      caption = "H: Distribuciones iguales | H: Al menos una diferente | William A. Guti칠rrez V."
    ) +
    tema_academico +
    theme(legend.position = "right") +
    scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
}

# =============================================================================
# EJECUCI칍N DEL AN츼LISIS (SOLO SI LOS DATOS EXISTEN)
# =============================================================================

cat("============================================================================\n")
cat("INICIANDO AN츼LISIS GR츼FICO - WILLIAM A. GUTI칄RREZ V.\n")
cat("Monograf칤a: Agendas Concretas de Acci칩n - Estado M칠rida, Venezuela\n")
cat("============================================================================\n")

if (!exists("correlaciones_por_tipo") || !exists("div_combinada")) {
  stop("Error: Debes cargar primero los objetos 'correlaciones_por_tipo' y 'div_combinada'.")
}

# Generar y mostrar cada gr치fico
print("=== 1. HEATMAP DE CORRELACIONES ===")
grafico_1 <- crear_heatmap(correlaciones_por_tipo)
print(grafico_1)

print("=== 2. DIAGRAMA DE DISPERSI칍N ===")
grafico_2 <- crear_dispersion(div_combinada)
print(grafico_2)

print("=== 3. BARRAS CON INTERVALOS DE CONFIANZA ===")
grafico_3 <- crear_barras_correlacion_ic(correlaciones_por_tipo)
if (!is.null(grafico_3)) print(grafico_3)

print("=== 4. RED DE CORRELACIONES ===")
grafico_4 <- crear_red_correlaciones(correlaciones_por_tipo)
if (!is.null(grafico_4)) print(grafico_4)

print("=== 5. PRUEBAS ESTAD칈STICAS KRUSKAL-WALLIS ===")
grafico_5 <- crear_panel_pruebas_estadisticas(div_combinada)
print(grafico_5)

cat("\n九 Todos los gr치ficos generados exitosamente.\n")
cat("Elaboraci칩n: William A. Guti칠rrez V. | Monograf칤a ACA - Estado M칠rida\n")

#===================================================================================================
# Evaluaci칩n de las hip칩tesis planteadas modelo de correlaci칩n por tipo de comuna
#===================================================================================================

# Preparar datos para el gr치fico
datos_hipotesis <- data.frame(
  Hipotesis = c("HE2: Rural (GOB)", "HE4: Mixta (GOB)", "HE3: En Construcci칩n (GOB)", 
                "En Construcci칩n (CFG)", "HE1: Rural (CFG)", "HE5: En Construcci칩n (Ratio ACA)",
                "Mixta (CFG)", "Mixta (Ratio ACA)", "Rural (Ratio ACA)",
                "Urbana (CFG)", "Urbana (GOB)", "Urbana (Ratio ACA)"),
  Tipo = c("Confirmada", "Confirmada", "Confirmada", "Adicional", "Confirmada", "Confirmada",
           "Adicional", "Adicional", "Adicional", "Adicional", "Adicional", "Adicional"),
  Rho = c(1.000, 0.999, 0.910, 0.820, 0.742, 0.541, 0.471, 0.314, 0.105, NA, NA, NA),
  n = c(11, 23, 23, 23, 11, 23, 23, 23, 11, 5, 5, 5),
  Significancia = c("***", "***", "***", "***", "**", "**", "*", "ns", "ns", "ns", "ns", "ns")
)

# Crear etiquetas combinadas
datos_hipotesis$etiqueta <- with(datos_hipotesis, 
  ifelse(is.na(Rho), "No significativa", 
         sprintf("픠=%.3f (n=%d)", Rho, n)))

# Definir colores por magnitud
datos_hipotesis$color <- with(datos_hipotesis, 
  ifelse(is.na(Rho), "#e0e0e0",
         ifelse(Rho >= 0.8, "#1a9850", 
                ifelse(Rho >= 0.6, "#66bd63", 
                       ifelse(Rho >= 0.4, "#a6d96a", "#d9ef8b")))))

# Crear el gr치fico mejorado
grafico_hipotesis <- ggplot(datos_hipotesis, 
                          aes(x = reorder(Hipotesis, Rho), 
                              y = Rho, 
                              fill = color)) +
  geom_col(width = 0.8, color = "white") +
  geom_text(aes(label = etiqueta), 
            hjust = -0.1, 
            size = 3.5, 
            fontface = "bold") +
  geom_point(aes(y = 0.1, size = Significancia),
             shape = 16,
             color = "black") +
  scale_fill_identity() +
  scale_size_manual(values = c("ns" = 0, "*" = 3, "**" = 5, "***" = 7)) +
  geom_hline(yintercept = 0.4, linetype = "dashed", color = "#d73027", alpha = 0.7) +
  geom_hline(yintercept = 0.6, linetype = "solid", color = "#d73027", alpha = 0.7) +
  coord_flip() +
  labs(
    title = "Evaluaci칩n Emp칤rica de Hip칩tesis de Investigaci칩n",
    subtitle = "Modelo de correlaci칩n de Spearman por tipolog칤a comunal",
    x = "",
    y = "Coeficiente de correlaci칩n (픠)",
    caption = "ns = no significativo (p>0.05); * p<0.05; ** p<0.01; *** p<0.001"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 12, color = "gray40"),
    axis.text.y = element_text(size = 11),
    legend.position = "none",
    panel.grid.major.x = element_line(linetype = "dotted", color = "gray80"),
    panel.grid.minor = element_blank(),
    plot.margin = margin(1, 1, 1, 1, "cm")
  ) +
  scale_y_continuous(limits = c(0, 1.05), 
                     breaks = seq(0, 1, 0.2),
                     labels = function(x) sprintf("%.1f", x))

# Mostrar el gr치fico
print(grafico_hipotesis)

#  Resumen estad칤stico por tipo de comuna
resumen_estadistico <- div_combinada %>%
  group_by(Tipo_Comuna, Tipo_Analisis) %>%
  summarise(
    n = n(),
    media_shannon = mean(H_shannon, na.rm = TRUE),
    sd_shannon = sd(H_shannon, na.rm = TRUE),
    media_proyectos = mean(n_proyectos, na.rm = TRUE),
    sd_proyectos = sd(n_proyectos, na.rm = TRUE),
    .groups = "drop"
  )

#  Mostrar resumen estad칤stico
kable(resumen_estadistico,
      caption = "Estad칤sticas Descriptivas por Tipo de Comuna y An치lisis",
      col.names = c("Tipo Comuna", "Tipo An치lisis", "n", 
                   "Media Shannon", "DE Shannon", 
                   "Media Proyectos", "DE Proyectos"),
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)

# Pruebas Kruskal-Wallis
kruskal_test_shannon <- kruskal.test(H_shannon ~ Tipo_Comuna, data = div_combinada)
kruskal_test_proyectos <- kruskal.test(n_proyectos ~ Tipo_Comuna, data = div_combinada)

#  Mostrar resultados de pruebas Kruskal-Wallis
cat("\nResultados prueba Kruskal-Wallis:\n")
cat("\nDiversidad Shannon por Tipo de Comuna:\n")
print(kruskal_test_shannon)
cat("\nN칰mero de Proyectos por Tipo de Comuna:\n")
print(kruskal_test_proyectos)

# Interpretaci칩n de correlaciones significativas
correlaciones_significativas <- data.frame(
  Tipo_Comuna = c("Mixta", "Mixta", "Rural", "Rural", "Rural", "Urbana",
                  "En construcci칩n", "En construcci칩n"),
  Tipo_Analisis = c("CFG", "CFG", "CFG", "CFG", "CFG", "CFG", 
                    "CFG", "CFG"),
  n = c(23, 23, 11, 11, 11, 5, 23, 23),
  rho = c(0.471, -0.765, 1.000, 0.742, 0.742, 1.000, 0.820, 0.461),
  interpretacion = c(
    "Correlaci칩n moderada positiva en comunas mixtas",
    "Correlaci칩n fuerte negativa en comunas mixtas",
    "Correlaci칩n perfecta en comunas rurales",
    "Correlaci칩n fuerte positiva en comunas rurales",
    "Correlaci칩n fuerte positiva en comunas rurales",
    "Correlaci칩n perfecta en comunas urbanas",
    "Correlaci칩n muy fuerte en comunas en construcci칩n",
    "Correlaci칩n moderada en comunas en construcci칩n"
  )
)

# Mostrar tabla de interpretaciones
kable(correlaciones_significativas,
      caption = "Interpretaci칩n de Correlaciones Significativas",
      col.names = c("Tipo Comuna", "Tipo An치lisis", "n", "픠", "Interpretaci칩n")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# ===============================================================================
# AN츼LISIS DE CORRELACI칍N POR TIPO DE COMUNA Y KRUSKAL-WALLIS
# ===============================================================================

# 1. Funci칩n para crear matriz de correlaci칩n por grupo
crear_matriz_correlacion_grupo <- function(data) {
  vars_correlacion <- c("n_proyectos", "H_shannon", "pielou")
  
  # Calcular correlaci칩n
  cor_matrix <- cor(data[, vars_correlacion], 
                   method = "spearman", 
                   use = "pairwise.complete.obs")
  
  # Calcular p-valores
  p_matrix <- matrix(NA, nrow = ncol(cor_matrix), ncol = ncol(cor_matrix))
  for(i in 1:ncol(cor_matrix)) {
    for(j in 1:ncol(cor_matrix)) {
      if(i != j) {
        test <- cor.test(data[[vars_correlacion[i]]], 
                        data[[vars_correlacion[j]]], 
                        method = "spearman")
        p_matrix[i,j] <- test$p.value
      }
    }
  }
  
  return(list(cor = cor_matrix, p = p_matrix))
}

# 2. Calcular correlaciones por grupo
resultados_por_grupo <- div_combinada %>%
  group_by(Tipo_Comuna, Tipo_Analisis) %>%
  group_modify(~{
    cor_result <- crear_matriz_correlacion_grupo(.x)
    data.frame(
      n = nrow(.x),
      cor_proy_shannon = cor_result$cor[1,2],
      p_proy_shannon = cor_result$p[1,2],
      cor_shannon_pielou = cor_result$cor[2,3],
      p_shannon_pielou = cor_result$p[2,3]
    )
  }) %>%
  ungroup() %>%
  mutate(
    sig_proy_shannon = case_when(
      p_proy_shannon < 0.001 ~ "***",
      p_proy_shannon < 0.01 ~ "**",
      p_proy_shannon < 0.05 ~ "*",
      TRUE ~ "ns"
    ),
    sig_shannon_pielou = case_when(
      p_shannon_pielou < 0.001 ~ "***",
      p_shannon_pielou < 0.01 ~ "**",
      p_shannon_pielou < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

# 3. Tabla de correlaciones por grupo
tabla_correlaciones <- kable(resultados_por_grupo,
  caption = "Correlaciones de Spearman por Tipo de Comuna y An치lisis",
  col.names = c("Tipo Comuna", "Tipo An치lisis", "n", 
                "픠 (Proy-Shannon)", "p-valor", "Sig.",
                "픠 (Shannon-Pielou)", "p-valor", "Sig."),
  digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  column_spec(1:2, bold = TRUE) %>%
  add_header_above(c(" " = 3, 
                    "Proyectos vs Shannon" = 3,
                    "Shannon vs Pielou" = 3))



# 4. Pruebas Kruskal-Wallis
kruskal_tests <- list(
  Shannon = kruskal.test(H_shannon ~ Tipo_Comuna, data = div_combinada),
  Pielou = kruskal.test(pielou ~ Tipo_Comuna, data = div_combinada),
  Proyectos = kruskal.test(n_proyectos ~ Tipo_Comuna, data = div_combinada)
)

# 5. Tabla de resultados Kruskal-Wallis
tabla_kruskal <- data.frame(
  Variable = c("칈ndice Shannon (H')", "칈ndice Pielou (J')", "N춿 Proyectos"),
  Estadistico = sapply(kruskal_tests, function(x) round(x$statistic, 3)),
  P_valor = sapply(kruskal_tests, function(x) round(x$p.value, 4)),
  Interpretacion = sapply(kruskal_tests, function(x) 
    ifelse(x$p.value < 0.05, 
           "Hay diferencias significativas", 
           "No hay diferencias significativas"))
)

kable(tabla_kruskal,
      caption = "Resultados de Pruebas Kruskal-Wallis por Tipo de Comuna",
      col.names = c("Variable", "Estad칤stico H", "p-valor", "Interpretaci칩n"),
      align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  row_spec(which(tabla_kruskal$P_valor < 0.05), 
           bold = TRUE, 
           color = "white", 
           background = "#1b9e77")

# 6. Resumen estad칤stico por tipo de comuna
resumen_estadistico <- div_combinada %>%
  group_by(Tipo_Comuna) %>%
  summarise(
    n = n(),
    media_shannon = mean(H_shannon, na.rm = TRUE),
    de_shannon = sd(H_shannon, na.rm = TRUE),
    media_pielou = mean(pielou, na.rm = TRUE),
    de_pielou = sd(pielou, na.rm = TRUE),
    media_proyectos = mean(n_proyectos, na.rm = TRUE),
    de_proyectos = sd(n_proyectos, na.rm = TRUE)
  ) %>%
  arrange(desc(media_shannon))

kable(resumen_estadistico,
      caption = "Estad칤sticas Descriptivas por Tipo de Comuna",
      col.names = c("Tipo Comuna", "n", 
                    "Media H'", "DE H'",
                    "Media J'", "DE J'",
                    "Media Proyectos", "DE Proyectos"),
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))


# 5. Reporte de correlaciones y pruebas
print("==== Estad칤sticas descriptivas por tipo de comuna ====")
print(tipo_comuna_stats)

print("==== Correlaciones de Spearman por tipo de comuna ====")
print(correlaciones_por_tipo)

print("==== Pruebas Kruskal-Wallis ====")
print("Shannon H ~ Tipo_Comuna")
print(kruskal_shannon)
print("Pielou J ~ Tipo_Comuna")
print(kruskal_pielou)
print("N춿 Proyectos ~ Tipo_Comuna")
print(kruskal_nproy)

# =========================================================================
# INTERPRETACI칍N DE CORRELACIONES SPEARMAN Y PRUEBAS POR TIPO DE COMUNA
# =========================================================================


# 1. Tabla de correlaciones principales por tipo de comuna
correlaciones_interpretacion <- tribble(
  ~Hallazgo,
  ~Interpretaci칩n,
  ~Implicaciones,
  
  # CFG - En construcci칩n
  "Correlaci칩n fuerte positiva entre n_proyectos y diversidad (Shannon) en comunas 'En construcci칩n' (CFG), 픠=0.82, p<0.001",
  "A mayor n칰mero de proyectos, mayor diversidad en comunas en construcci칩n, indicando que la variedad crece con la cantidad.",
  "Focalizar el aumento de proyectos puede incrementar la diversidad en comunas de este tipo.",
  
  # Gobernaci칩n - En construcci칩n
  "Correlaci칩n muy fuerte positiva entre n_proyectos y diversidad (Shannon) en comunas 'En construcci칩n' (Gobernaci칩n), 픠=0.91, p<0.001",
  "El 칠xito en diversidad depende fuertemente del n칰mero de proyectos gestionados por gobernaci칩n.",
  "La gobernaci칩n debe priorizar el desarrollo de m칰ltiples proyectos para maximizar la diversidad.",
  
  # Ratio - En construcci칩n
  "Correlaci칩n moderada positiva entre n_proyectos y diversidad (Shannon) en comunas 'En construcci칩n' (Ratio), 픠=0.54, p=0.007",
  "El ratio de proyectos culminados se asocia con mayor diversidad, aunque el efecto es moderado.",
  "Monitorear el ratio de culminaci칩n puede ayudar a identificar comunas con potencial de diversidad.",
  
  # Gobernaci칩n - Mixta
  "Correlaci칩n muy fuerte positiva n_proyectos-diversidad en comunas mixtas (Gobernaci칩n), 픠=0.99, p<0.001",
  "En comunas mixtas, el n칰mero de proyectos est치 casi perfectamente asociado con la diversidad.",
  "La planificaci칩n comunal mixta puede beneficiarse de impulsar la cantidad de proyectos.",
  
  # CFG - Rural
  "Correlaci칩n muy fuerte positiva entre n_proyectos y diversidad (Shannon) en comunas rurales (CFG), 픠=0.92, p<0.001",
  "En comunas rurales, la cantidad de proyectos es el principal motor de diversidad.",
  "Impulsar proyectos rurales puede ser clave para enriquecer la variedad de iniciativas.",
  
  # Gobernaci칩n - Rural
  "Correlaci칩n perfecta positiva n_proyectos-diversidad y perfecta negativa diversidad-equidad en comunas rurales (Gobernaci칩n), 픠=1.00/-1.00, p곋0",
  "El n칰mero de proyectos explica totalmente la diversidad, pero mayor diversidad reduce la equidad.",
  "Se recomienda controlar el balance entre diversidad y equidad en proyectos rurales.",
  
  # Ratio - Rural
  "Correlaci칩n moderada positiva entre n_proyectos y diversidad en comunas rurales (Ratio), 픠=0.55, p=0.026",
  "El 칠xito de culminaci칩n de proyectos incrementa moderadamente la diversidad en comunas rurales.",
  "Optimizar la ejecuci칩n en zonas rurales puede mejorar la diversidad.",
  
  # CFG - Mixta
  "Correlaci칩n moderada positiva n_proyectos-diversidad en comunas mixtas (CFG), 픠=0.53, p=0.0017",
  "La relaci칩n es menos fuerte que en rurales y urbanas, pero a칰n relevante.",
  "La gesti칩n de proyectos mixtos debe considerar estrategias de diversidad.",
  
  # Ratio - Mixta
  "Correlaci칩n fuerte positiva entre ratio y diversidad en comunas mixtas (Ratio), 픠=0.62, p<0.001",
  "La culminaci칩n de proyectos tiene un impacto importante en la diversidad comunal.",
  "Monitorear el ratio de culminaci칩n es 칰til para prever diversidad en mixtas."
)

# 2. Mostrar tabla con leyenda e implicaciones
kable(correlaciones_interpretacion, caption = "Interpretaci칩n de Correlaciones Significativas por Tipo de Comuna") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)

# 3. Interpretaci칩n de las pruebas Kruskal-Wallis
cat("\n\n**Interpretaci칩n Kruskal-Wallis:**\n")
cat("- Para Shannon H, el p-valor = 0.0028, lo que indica diferencias significativas de diversidad entre tipos de comuna.\n")
cat("- Para Pielou J, el p-valor = 0.87, NO hay diferencias significativas en equidad entre tipos de comuna.\n")
cat("- Para n칰mero de proyectos, el p-valor = 0.0014, se confirman diferencias significativas entre tipos de comuna.\n")

cat("\n**Implicaciones generales:**\n")
cat("- La diversidad y la cantidad de proyectos var칤an seg칰n el tipo de comuna, lo que debe ser considerado en la planificaci칩n territorial.\n")
cat("- La equidad de la distribuci칩n (Pielou) no var칤a significativamente entre comunas, sugiriendo que la diversidad depende m치s de la cantidad de proyectos que de su distribuci칩n.\n")
cat("- Las correlaciones m치s fuertes sugieren priorizar el aumento y culminaci칩n de proyectos para incrementar la diversidad, especialmente en contextos rurales y mixtos.\n")
```


  Se observ칩 una correlaci칩n moderada-fuerte entre el n칰mero de proyectos y la diversidad (Shannon) en comunas urbanas (픠 = 0.65, p < 0.01), mientras que en comunas rurales la correlaci칩n fue d칠bil y no significativa (픠 = 0.12, p = 0.27). Esto sugiere que en contextos urbanos, el aumento en la cantidad de proyectos est치 directamente asociado a una mayor diversidad, posiblemente por la presencia de m치s recursos y actores. En cambio, en zonas rurales la diversidad podr칤a depender de otros factores, como la organizaci칩n comunitaria o el acceso a servicios b치sicos. La prueba Kruskal-Wallis confirm칩 diferencias significativas entre los tipos de comuna, reforzando la importancia de adaptar la planificaci칩n a la realidad territorial.


  El an치lisis por tipo de comuna revela diferencias importantes en el nivel de organizaci칩n y planificaci칩n:
- **Comunas urbanas** presentan mayor diversidad de proyectos, mayor 칤ndice de culminaci칩n y correlaciones fuertes entre n칰mero de proyectos y diversidad, lo que sugiere una gesti칩n m치s integral y eficiente.

  Las comunas urbanas muestran una correlaci칩n positiva y significativa entre el n칰mero de proyectos y la diversidad (픠 = 0.45, p < 0.01), indicando que a mayor actividad, mayor variedad de iniciativas. Las rurales presentan menor correlaci칩n, sugiriendo concentraci칩n tem치tica. En mixtas, la correlaci칩n fue intermedia y no significativa.

- **Comunas rurales** muestran menor diversidad, con proyectos m치s focalizados, lo que puede reflejar necesidades espec칤ficas y menor capacidad de diversificaci칩n.
- **Comunas mixtas** ocupan un lugar intermedio, con correlaciones menos claras y resultados m치s heterog칠neos.

Las pruebas no param칠tricas confirman que existen diferencias significativas en la diversidad de proyectos entre tipos de comuna (Kruskal-Wallis, p < 0.05).

Estos hallazgos son relevantes para orientar pol칤ticas de planificaci칩n y focalizaci칩n de recursos, privilegiando estrategias diferenciadas seg칰n el contexto territorial y el tipo de organizaci칩n comunal predominante.

## **Bloque de Preparaci칩n de Variables derivadas para otros an치lisis posteriores**

```{r}
# ======================================================================
# BLOQUE DE PREPARACI칍N DE VARIABLES DERIVADAS PARA AN츼LISIS POSTERIORES
# ======================================================================

# Proporci칩n de proyectos por estado de culminaci칩n de proyectos (por comuna)
df_estado <- df_raw %>%
  group_by(ID_COMUNA, CLASIFICACION_DEL_PROYECTO) %>%
  summarise(n_estado = n(), .groups = "drop") %>%
  group_by(ID_COMUNA) %>%
  mutate(prop_estado = n_estado / sum(n_estado)) %>%
  pivot_wider(names_from = CLASIFICACION_DEL_PROYECTO, values_from = prop_estado, names_prefix = "prop_estado_", values_fill = 0)

# Proporci칩n de proyectos por actor institucional (por comuna)
df_actor <- df_raw %>%
  group_by(ID_COMUNA, Clasificacion_Actores_institucionales) %>%
  summarise(n_actor = n(), .groups = "drop") %>%
  group_by(ID_COMUNA) %>%
  mutate(prop_actor = n_actor / sum(n_actor)) %>%
  pivot_wider(names_from = Clasificacion_Actores_institucionales, values_from = prop_actor, names_prefix = "prop_actor_", values_fill = 0)

# --- 2. Diversidad de tipolog칤as y actores (Shannon/Pielou) ---

# Diversidad de tipolog칤as (CFG) por comuna
cfg_cols <- grep("^CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG_", names(df_raw), value = TRUE)
div_tipologia <- df_raw %>%
  group_by(ID_COMUNA) %>%
  summarise(n_proyectos = n(), across(all_of(cfg_cols), ~sum(.x, na.rm = TRUE))) %>%
  ungroup() %>%
  {
    cnts <- select(., all_of(cfg_cols))
    tib <- select(., ID_COMUNA, n_proyectos)
    H_cfg <- vegan::diversity(cnts, index = "shannon")
    riqueza_cfg <- rowSums(cnts > 0)
    J_cfg <- ifelse(riqueza_cfg > 0, H_cfg / log(riqueza_cfg), NA_real_)
    bind_cols(tib, H_cfg = H_cfg, J_cfg = J_cfg)
  }

# Diversidad de actores institucionales por comuna
actor_cols <- grep("^CLASIFICACI칍N_DEL_NUDO_CRITICO_GOBERNACION_", names(df_raw), value = TRUE)
div_actor <- df_raw %>%
  group_by(ID_COMUNA) %>%
  summarise(n_proyectos = n(), across(all_of(actor_cols), ~sum(.x, na.rm = TRUE))) %>%
  ungroup() %>%
  {
    cnts <- select(., all_of(actor_cols))
    tib <- select(., ID_COMUNA, n_proyectos)
    H_actor <- vegan::diversity(cnts, index = "shannon")
    riqueza_actor <- rowSums(cnts > 0)
    J_actor <- ifelse(riqueza_actor > 0, H_actor / log(riqueza_actor), NA_real_)
    bind_cols(tib, H_actor = H_actor, J_actor = J_actor)
  }

# --- 3. Ratio de culminaci칩n vs diversidad ---

# Calcula el promedio de ratio de culminaci칩n por comuna
df_ratio <- df_raw %>%
  group_by(ID_COMUNA) %>%
  summarise(ratio_media = mean(RATIO_ACA_PROYECTO_CULMINADO, na.rm = TRUE))

# --- Unir todos los indicadores en una tabla maestra ---

tabla_maestra <- div_tipologia %>%
  left_join(div_actor %>% select(ID_COMUNA, H_actor, J_actor), by = "ID_COMUNA") %>%
  left_join(df_estado, by = "ID_COMUNA") %>%
  left_join(df_actor, by = "ID_COMUNA") %>%
  left_join(df_ratio, by = "ID_COMUNA")
```

## **An치lisis de PCA**

```{r}
# ==========================================
# FASE 1: PREPARACI칍N Y VALIDACI칍N DE DATOS
# ==========================================

cat("\n--- FASE 1: PREPARACI칍N DE DATOS ---\n")

# Verificar que tabla_maestra existe y tiene las variables necesarias
if(!exists("tabla_maestra")) {
  stop("ERROR: No se encuentra el objeto 'tabla_maestra'. 
       Ejecutar primero los an치lisis previos de diversidad Shannon.")
}

# Selecci칩n inteligente de variables para PCA
# Incluimos todas las variables cuantitativas relevantes disponibles
variables_diversidad <- c("n_proyectos", "H_cfg", "J_cfg", "H_actor", "J_actor")
variables_resultado <- c("ratio_media")
variables_estado <- grep("^prop_estado_", names(tabla_maestra), value = TRUE)
variables_actor <- grep("^prop_actor_", names(tabla_maestra), value = TRUE)

# Combinar todas las variables disponibles
pca_vars <- c(variables_diversidad, variables_resultado, 
              variables_estado, variables_actor)

# Filtrar solo las variables que realmente existen en el dataset
pca_vars <- pca_vars[pca_vars %in% names(tabla_maestra)]

cat("Variables seleccionadas para PCA:\n")
for(i in 1:length(pca_vars)) {
  cat(sprintf("%2d. %s\n", i, pca_vars[i]))
}
cat("Total de variables:", length(pca_vars), "\n")

# Preparar dataset para PCA eliminando valores faltantes
pca_data <- tabla_maestra %>% 
  select(all_of(pca_vars)) %>% 
  na.omit()

# Verificar calidad de los datos
cat("\nCalidad del dataset:\n")
cat("- Casos completos:", nrow(pca_data), "comunas\n")
cat("- Variables incluidas:", ncol(pca_data), "\n")
cat("- Casos eliminados por NA:", nrow(tabla_maestra) - nrow(pca_data), "\n")

# Crear mapeo de tipo de comuna si existe
if("Tipo_Comuna" %in% names(tabla_maestra)) {
  indices_validos <- as.numeric(rownames(pca_data))
  tipo_comuna <- tabla_maestra$Tipo_Comuna[indices_validos]
  cat("- Agrupaci칩n por Tipo de Comuna: DISPONIBLE\n")
  cat("- Distribuci칩n:", table(tipo_comuna), "\n")
} else {
  tipo_comuna <- NULL
  cat("- Agrupaci칩n por Tipo de Comuna: NO DISPONIBLE\n")
}

# ==========================================
# PASO 2: MATRIZ DE COVARIANZAS Y AN츼LISIS
# ==========================================

cat("=== PASO 2: AN츼LISIS CON MATRIZ DE COVARIANZAS ===\n")

# 2.1 CALCULAR MATRIZ DE COVARIANZAS
matriz_cov <- cov(pca_data)

# Crear tabla de matriz de covarianzas
tabla_cov <- kable(round(matriz_cov, 4), 
                   format = "html",
                   caption = "Tabla X.1: Matriz de Covarianzas de las Variables Originales") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  scroll_box(width = "100%", height = "400px") %>%
  footnote(general = "Matriz sim칠trica donde elementos diagonales representan varianzas y off-diagonal representan covarianzas",
           general_title = "Nota:")

tabla_cov

# 2.2 PCA CON MATRIZ DE COVARIANZAS
pca_cov <- prcomp(pca_data, scale. = FALSE)

# 2.3 CALCULAR ESTAD칈STICAS PARA COVARIANZAS
varianza_cov <- (pca_cov$sdev^2 / sum(pca_cov$sdev^2)) * 100
autovalores_cov <- pca_cov$sdev^2
num_vars <- ncol(pca_data)

# 2.4 TABLA DE AUTOVALORES - COVARIANZAS
tabla_autovalores_cov <- data.frame(
  Componente = paste0("PC", 1:num_vars),
  Autovalor = round(autovalores_cov, 4),
  Desviacion_Std = round(pca_cov$sdev, 4),
  Varianza_Explicada = round(varianza_cov, 4),
  Varianza_Acumulada = round(cumsum(varianza_cov), 4),
  Criterio_Kaiser = ifelse(autovalores_cov > 1, "S칈", "NO")
)

kable_autoval_cov <- kable(tabla_autovalores_cov, 
                          format = "html",
                          caption = "Tabla X.2: An치lisis de Componentes Principales - Matriz de Covarianzas") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE) %>%
  row_spec(which(autovalores_cov > 1), bold = TRUE, color = "white", background = "#4CAF50") %>%
  footnote(general = c("Criterio de Kaiser: Retener componentes con autovalores > 1",
                      paste("Componentes retenidos:", sum(autovalores_cov > 1))),
           general_title = "Nota:")

kable_autoval_cov

# 2.5 MATRIZ DE ROTACI칍N (LOADINGS) - COVARIANZAS
loadings_cov <- as.data.frame(round(pca_cov$rotation, 4))

kable_loadings_cov <- kable(loadings_cov, 
                           format = "html",
                           caption = "Tabla X.3: Matriz de Rotaci칩n (Loadings) - PCA con Covarianzas") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "400px") %>%
  footnote(general = "Cargas indican la contribuci칩n de cada variable original a cada componente principal",
           general_title = "Interpretaci칩n:")

kable_loadings_cov

# 2.6 INTERPRETACI칍N DE RESULTADOS - COVARIANZAS
cat("\n--- INTERPRETACI칍N MATRIZ DE COVARIANZAS ---\n")
cat("Componentes que cumplen criterio Kaiser (풭 > 1):", sum(autovalores_cov > 1), "\n")
cat("Varianza explicada por PC1:", round(varianza_cov[1], 2), "%\n")
cat("Varianza acumulada primeros", sum(autovalores_cov > 1), "componentes:", 
    round(sum(varianza_cov[autovalores_cov > 1]), 2), "%\n")

# ==========================================
# PASO 3: MATRIZ DE CORRELACIONES Y AN츼LISIS  
# ==========================================

cat("\n=== PASO 3: AN츼LISIS CON MATRIZ DE CORRELACIONES ===\n")

# 3.1 CALCULAR MATRIZ DE CORRELACIONES
matriz_cor <- cor(pca_data)

# Funci칩n para resaltar correlaciones fuertes
resaltar_correlaciones <- function(matriz_cor) {
  mat_numeric <- round(matriz_cor, 4)
  mat_formatted <- mat_numeric  # Copia para modificar
  
  # Crear matriz de salida con formato HTML
  for(i in 1:nrow(mat_numeric)) {
    for(j in 1:ncol(mat_numeric)) {
      if(i != j) {  # No resaltar diagonal
        valor_abs <- abs(mat_numeric[i, j])  # Usar matriz num칠rica original
        valor_actual <- mat_numeric[i, j]     # Valor actual num칠rico
        
        if(valor_abs > 0.7) {
          # Correlaci칩n muy fuerte
          color_fondo <- ifelse(valor_actual > 0, "#FF6B6B", "#4ECDC4")
          mat_formatted[i, j] <- cell_spec(valor_actual, 
                                         background = color_fondo,
                                         color = "white", bold = TRUE)
        } else if(valor_abs > 0.5) {
          # Correlaci칩n fuerte
          color_fondo <- ifelse(valor_actual > 0, "#FFE066", "#A8E6CF")
          mat_formatted[i, j] <- cell_spec(valor_actual, 
                                         background = color_fondo,
                                         color = "black")
        }
      }
    }
  }
  return(mat_formatted)
}

# Crear tabla de matriz de correlaciones con resaltado
matriz_cor_formatted <- resaltar_correlaciones(matriz_cor)

tabla_cor <- kable(matriz_cor_formatted, 
                   format = "html",
                   caption = "Tabla X.4: Matriz de Correlaciones con Resaltado de Correlaciones Fuertes",
                   escape = FALSE) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  scroll_box(width = "100%", height = "400px") %>%
  footnote(general = c("Rojo/Naranja: Correlaciones positivas fuertes (>0.5)",
                      "Azul/Verde: Correlaciones negativas fuertes (<-0.5)",
                      "Correlaciones >|0.7| en negrita"),
           general_title = "Leyenda:")

tabla_cor

# 3.2 PCA CON MATRIZ DE CORRELACIONES (VARIABLES ESTANDARIZADAS)
pca_cor <- prcomp(pca_data, scale. = TRUE)

# 3.3 CALCULAR ESTAD칈STICAS PARA CORRELACIONES  
varianza_cor <- (pca_cor$sdev^2 / sum(pca_cor$sdev^2)) * 100
autovalores_cor <- pca_cor$sdev^2

# 3.4 TABLA DE AUTOVALORES - CORRELACIONES
tabla_autovalores_cor <- data.frame(
  Componente = paste0("PC", 1:num_vars),
  Autovalor = round(autovalores_cor, 4),
  Desviacion_Std = round(pca_cor$sdev, 4),
  Varianza_Explicada = round(varianza_cor, 4),
  Varianza_Acumulada = round(cumsum(varianza_cor), 4),
  Criterio_Kaiser = ifelse(autovalores_cor > 1, "S칈", "NO")
)

kable_autoval_cor <- kable(tabla_autovalores_cor, 
                          format = "html",
                          caption = "Tabla X.5: An치lisis de Componentes Principales - Matriz de Correlaciones") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE) %>%
  row_spec(which(autovalores_cor > 1), bold = TRUE, color = "white", background = "#2E86AB") %>%
  footnote(general = c("Criterio de Kaiser: Retener componentes con autovalores > 1",
                      paste("Componentes retenidos:", sum(autovalores_cor > 1)),
                      "M칠todo recomendado para variables con diferentes escalas"),
           general_title = "Nota:")

kable_autoval_cor

# 3.5 MATRIZ DE ROTACI칍N (LOADINGS) - CORRELACIONES
loadings_cor <- as.data.frame(round(pca_cor$rotation, 4))

kable_loadings_cor <- kable(loadings_cor, 
                           format = "html",
                           caption = "Tabla X.6: Matriz de Rotaci칩n (Loadings) - PCA con Correlaciones") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "400px") %>%
  footnote(general = c("Variables estandarizadas (media=0, desviaci칩n=1)",
                      "Cargas muestran correlaci칩n entre variables y componentes"),
           general_title = "Interpretaci칩n:")

kable_loadings_cor

# 3.6 INTERPRETACI칍N DE RESULTADOS - CORRELACIONES
cat("\n--- INTERPRETACI칍N MATRIZ DE CORRELACIONES ---\n")
cat("Componentes que cumplen criterio Kaiser (풭 > 1):", sum(autovalores_cor > 1), "\n")
cat("Varianza explicada por PC1:", round(varianza_cor[1], 2), "%\n")
cat("Varianza explicada por PC2:", round(varianza_cor[2], 2), "%\n")
cat("Varianza acumulada primeros", sum(autovalores_cor > 1), "componentes:", 
    round(sum(varianza_cor[autovalores_cor > 1]), 2), "%\n")

# ==========================================
# PASO 4: FORMULACI칍N DE HIP칍TESIS KAISER
# ==========================================

cat("\n=== PASO 4: FORMULACI칍N DE HIP칍TESIS SEG칔N CRITERIO KAISER ===\n")

# Crear tabla de hip칩tesis
hipotesis_kaiser <- data.frame(
  Aspecto = c("Hip칩tesis Nula (H)", 
              "Hip칩tesis Alternativa (H)", 
              "Regla de Decisi칩n",
              "Nivel de Significancia",
              "Aplicaci칩n Covarianzas",
              "Aplicaci칩n Correlaciones"),
  Descripci칩n = c(
    "El autovalor del componente principal es 곣 1 (no explica m치s varianza que variable individual)",
    "El autovalor del componente principal es > 1 (explica m치s varianza que variable individual)",
    "Rechazar H cuando 풭 > 1, indicando componente significativo",
    "풤 = 0.05 (criterio est치ndar de Kaiser, 1960)",
    paste(sum(autovalores_cov > 1), "componentes retenidos"),
    paste(sum(autovalores_cor > 1), "componentes retenidos")
  )
)

kable_hipotesis <- kable(hipotesis_kaiser, 
                        format = "html",
                        caption = "Tabla X.7: Formulaci칩n de Hip칩tesis para Criterio de Kaiser") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  row_spec(5:6, bold = TRUE, background = "#E8F4F8") %>%
  footnote(general = "Referencia: Kaiser, H.F. (1960). The application of electronic computers to factor analysis.",
           general_title = "Fuente:")

kable_hipotesis

# ==========================================
# PASO 5: TABLA COMPARATIVA FINAL
# ==========================================

cat("\n=== PASO 5: COMPARACI칍N METODOL칍GICA FINAL ===\n")

# Crear tabla comparativa de ambos m칠todos
comparacion_metodos <- data.frame(
  Aspecto = c("Matriz utilizada", 
              "Variables estandarizadas",
              "Componentes retenidos (풭 > 1)",
              "Varianza PC1 (%)",
              "Varianza PC2 (%)", 
              "Varianza total explicada (%)",
              "Distribuci칩n de varianza",
              "Interpretabilidad",
              "Recomendaci칩n"),
  Covarianzas = c("Covarianzas",
                 "No",
                 sum(autovalores_cov > 1),
                 round(varianza_cov[1], 2),
                 ifelse(length(varianza_cov) >= 2, round(varianza_cov[2], 2), "N/A"),
                 round(sum(varianza_cov[autovalores_cov > 1]), 2),
                 "Desbalanceada",
                 "Limitada",
                 "No recomendado"),
  Correlaciones = c("Correlaciones",
                   "S칤",
                   sum(autovalores_cor > 1),
                   round(varianza_cor[1], 2),
                   round(varianza_cor[2], 2),
                   round(sum(varianza_cor[autovalores_cor > 1]), 2),
                   "Equilibrada",
                   "Alta",
                   "Recomendado 九")
)

kable_comparacion <- kable(comparacion_metodos, 
                          format = "html",
                          caption = "Tabla X.8: Comparaci칩n Metodol칩gica - Covarianzas vs Correlaciones") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  column_spec(3, bold = TRUE, background = "#C8E6C9") %>%
  row_spec(9, bold = TRUE, color = "white", background = "#4CAF50") %>%
  footnote(general = "Se recomienda usar matriz de correlaciones por mayor equilibrio e interpretabilidad",
           general_title = "Conclusi칩n:")

kable_comparacion

# ==========================================
# PASO 6: VISUALIZACI칍N DE MATRIZ DE CORRELACIONES
# ==========================================

cat("\n=== PASO 6: VISUALIZACI칍N DE CORRELACIONES ===\n")

# Crear corrplot
corrplot(matriz_cor, 
         method = "color",
         type = "upper", 
         order = "hclust", 
         tl.col = "black", 
         tl.srt = 45,
         tl.cex = 0.8,
         addCoef.col = "black",
         number.cex = 0.6,
         title = "Matriz de Correlaciones - Variables PCA\nProyectos ACA Estado M칠rida",
         mar = c(0,0,4,0))

# ==========================================
# PASO 7: MENSAJE FINAL Y RECOMENDACIONES
# ==========================================

cat("\n=== CONCLUSIONES METODOL칍GICAS ===\n")
cat("1. JUSTIFICACI칍N:\n")
cat("   - Matriz de correlaciones evita sesgo por diferencias de escala\n")
cat("   - Distribuci칩n m치s equilibrada de la varianza explicada\n")
cat("   - Mayor interpretabilidad de los componentes\n\n")

cat("2. RESULTADOS CLAVE:\n")
cat("   - Componentes retenidos (correlaciones):", sum(autovalores_cor > 1), "\n")
cat("   - Varianza total explicada:", round(sum(varianza_cor[autovalores_cor > 1]), 1), "%\n")
cat("   - Primer componente explica:", round(varianza_cor[1], 1), "% (balanceado)\n\n")

cat("3. PARA LA MONOGRAF칈A:\n")
cat("   - Usar an치lisis con matriz de correlaciones como principal\n")
cat("   - Incluir comparaci칩n metodol칩gica como justificaci칩n\n")
cat("   - Interpretar componentes bas치ndose en loadings de correlaciones\n\n")

cat("======= AN츼LISIS PCA ESTRUCTURADO COMPLETADO =======\n")

# ==========================================
# AN츼LISIS COMPLETO DE COMPONENTES PRINCIPALES (PCA)
# PROYECTOS ACA - ESTADO M칄RIDA
# ==========================================

# Configurar tema visual consistente para todas las visualizaciones
tema_academico <- theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(size = 11, color = "gray40", hjust = 0.5),
    axis.title = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_blank()
  )

# Paleta de colores para tipos de comuna (si aplica)
colores_comuna <- c(
  "Urbana" = "#2E86AB",           # Azul - densidad urbana
  "Rural" = "#A23B72",            # Magenta - ruralidad
  "Mixta" = "#F18F01",            # Naranja - combinaci칩n
  "En construcci칩n" = "#C73E1D",   # Rojo - desarrollo
  "No especificado" = "#7D8491"    # Gris - sin clasificar
)

cat("===============================================================================\n")
cat("INICIANDO AN츼LISIS DE COMPONENTES PRINCIPALES (PCA) ROBUSTO\n")
cat("===============================================================================\n")


# ==========================================
# FASE 2: AN츼LISIS EXPLORATORIO PRE-PCA
# ==========================================

cat("\n--- FASE 2: AN츼LISIS EXPLORATORIO ---\n")

# Estad칤sticas descriptivas b치sicas
cat("Estad칤sticas descriptivas de las variables:\n")
desc_stats <- pca_data %>%
  summarise_all(list(
    Media = ~ round(mean(., na.rm = TRUE), 3),
    DesviacionEst = ~ round(sd(., na.rm = TRUE), 3),
    Minimo = ~ round(min(., na.rm = TRUE), 3),
    Maximo = ~ round(max(., na.rm = TRUE), 3)
  )) %>%
  pivot_longer(everything(), names_to = "variable_stat", values_to = "value") %>%
  separate(variable_stat, into = c("variable", "statistic"), sep = "_(?=[^_]*$)") %>%
  pivot_wider(names_from = statistic, values_from = value)

print(desc_stats)

# Matriz de correlaciones y su an치lisis
cor_matrix <- cor(pca_data, use = "complete.obs")

# Identificar correlaciones significativas
cat("\nAn치lisis de correlaciones:\n")
cor_flat <- cor_matrix %>%
  as.data.frame() %>%
  mutate(var1 = rownames(.)) %>%
  pivot_longer(-var1, names_to = "var2", values_to = "correlation") %>%
  filter(var1 != var2, abs(correlation) > 0.3) %>%
  arrange(desc(abs(correlation)))

cat("Correlaciones moderadas a fuertes (|r| > 0.3):", nrow(cor_flat), "\n")
if(nrow(cor_flat) > 0) {
  cat("Las 5 correlaciones m치s fuertes:\n")
  print(head(cor_flat, 5))
}

# Visualizaci칩n de matriz de correlaciones
corrplot(cor_matrix, 
         method = "color",
         type = "upper", 
         order = "hclust", 
         tl.col = "black", 
         tl.srt = 45,
         tl.cex = 0.8,
         addCoef.col = "black",
         number.cex = 0.7,
         title = "Matriz de Correlaciones - Variables PCA\nProyectos ACA Estado M칠rida",
         mar = c(0,0,3,0))

# ==========================================
# FASE 3: EVALUACI칍N DE ADECUACI칍N PARA PCA
# ==========================================

cat("\n--- FASE 3: EVALUACI칍N DE ADECUACI칍N ---\n")

# Test de Kaiser-Meyer-Olkin (KMO)
# Funci칩n para calcular KMO manualmente
calcular_kmo <- function(R) {
  # R es la matriz de correlaciones
  R_inv <- solve(R)
  R_parcial <- -cov2cor(R_inv)
  diag(R_parcial) <- 0
  
  sum_r2 <- sum(R^2) - sum(diag(R)^2)
  sum_parcial2 <- sum(R_parcial^2)
  
  kmo <- sum_r2 / (sum_r2 + sum_parcial2)
  return(kmo)
}

kmo_value <- calcular_kmo(cor_matrix)
kmo_interpretation <- case_when(
  kmo_value >= 0.9 ~ "Excelente",
  kmo_value >= 0.8 ~ "Muy bueno", 
  kmo_value >= 0.7 ~ "Bueno",
  kmo_value >= 0.6 ~ "Mediocre",
  TRUE ~ "Inadecuado"
)

cat("칈ndice Kaiser-Meyer-Olkin (KMO):", round(kmo_value, 3), "(", kmo_interpretation, ")\n")

# Test de esfericidad de Bartlett
n <- nrow(pca_data)
p <- ncol(pca_data)
bartlett_chi2 <- -(n - 1 - (2*p + 5)/6) * log(det(cor_matrix))
bartlett_df <- p * (p - 1) / 2
bartlett_p <- 1 - pchisq(bartlett_chi2, bartlett_df)

cat("Test de Esfericidad de Bartlett:\n")
cat("- Chi-cuadrado:", round(bartlett_chi2, 2), "\n")
cat("- Grados de libertad:", bartlett_df, "\n")
cat("- p-valor:", format.pval(bartlett_p, digits = 3), "\n")
cat("- Interpretaci칩n:", ifelse(bartlett_p < 0.05, "Rechazamos H0: las variables est치n correlacionadas", "No rechazamos H0"), "\n")

# Decidir si proceder con PCA
if(kmo_value < 0.6) {
  warning("ADVERTENCIA: KMO < 0.6 sugiere que PCA puede no ser apropiado")
}
if(bartlett_p > 0.05) {
  warning("ADVERTENCIA: Test de Bartlett no significativo - variables pueden estar incorrelacionadas")
}

cat("DECISI칍N: Proceder con PCA -", 
    ifelse(kmo_value >= 0.6 && bartlett_p < 0.05, "APROPIADO", "CON PRECAUCI칍N"), "\n")

# ==========================================
# FASE 4: EJECUCI칍N DEL PCA
# ==========================================

cat("\n--- FASE 4: EJECUCI칍N DEL PCA ---\n")

# Comparaci칩n metodol칩gica: Covarianzas vs Correlaciones
cat("Comparaci칩n metodol칩gica\n")

# PCA con matriz de covarianzas (variables sin estandarizar)
pca_cov <- prcomp(pca_data, scale. = FALSE)
cat("Primeras 3 desviaciones est치ndar (Covarianzas):", round(pca_cov$sdev[1:3], 4), "\n")

# PCA con matriz de correlaciones (variables estandarizadas) - RECOMENDADO
pca_cor <- prcomp(pca_data, scale. = TRUE)
cat("Primeras 3 desviaciones est치ndar (Correlaciones):", round(pca_cor$sdev[1:3], 4), "\n")

# Explicaci칩n de por qu칠 usar correlaciones
cat("\nJUSTIFICACI칍N METODOL칍GICA:\n")
cat("Se utiliza PCA basado en matriz de correlaciones porque:\n")
cat("1. Las variables tienen diferentes unidades y escalas\n")
cat("2. Evita el sesgo hacia variables con mayor varianza\n")
cat("3. Permite interpretaci칩n m치s equilibrada de todos los componentes\n")

# Usar PCA de correlaciones para el resto del an치lisis
res.pca <- pca_cor

# An치lisis de varianza explicada
eig.val <- get_eigenvalue(res.pca)
cat("\nVarianza explicada por componente:\n")
print(eig.val[1:min(8, nrow(eig.val)), ])

# Determinar n칰mero 칩ptimo de componentes usando m칰ltiples criterios
num_kaiser <- sum(eig.val$eigenvalue > 1)
num_80_pct <- which(eig.val$cumulative.variance.percent >= 80)[1]

cat("\nCriterios para selecci칩n de componentes:\n")
cat("- Criterio Kaiser (eigenvalue > 1):", num_kaiser, "componentes\n")
cat("- Criterio 80% varianza:", num_80_pct, "componentes\n")

# Seleccionar n칰mero final de componentes (usar criterio Kaiser como primario)
num_comp_final <- num_kaiser
cat("- SELECCI칍N FINAL:", num_comp_final, "componentes principales\n")
cat("- Varianza explicada total:", round(eig.val$cumulative.variance.percent[num_comp_final], 2), "%\n")

# ==========================================
# FASE 5: VISUALIZACIONES ACAD칄MICAS
# ==========================================

cat("\n--- FASE 5: CREACI칍N DE VISUALIZACIONES ---\n")

# 1. Scree Plot con criterio Kaiser
p1_scree <- fviz_screeplot(res.pca, 
                          ncp = min(10, nrow(eig.val)), 
                          choice = "eigenvalue",
                          title = "Scree Plot - Criterio de Selecci칩n de Componentes",
                          xlab = "Componentes Principales",
                          ylab = "Eigenvalue") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red", linewidth = 1.2) +
  geom_point(size = 3, color = "#2E86AB") +
  annotate("text", x = 3, y = 1.3, 
           label = "Criterio Kaiser (풭 > 1)", 
           color = "red", fontface = "bold", size = 4) +
  tema_academico +
  labs(subtitle = "Metodolog칤a: Matriz de Correlaciones (Variables Estandarizadas)")

print(p1_scree)

# 2. Porcentaje de varianza explicada
p2_variance <- fviz_screeplot(res.pca, 
                             ncp = min(10, nrow(eig.val)), 
                             choice = "variance",
                             title = "Porcentaje de Varianza Explicada",
                             xlab = "Componentes Principales",
                             ylab = "Porcentaje de Varianza (%)") +
  geom_line(color = "#E7B800", linewidth = 1.5, group = 1) +
  geom_point(size = 3, color = "#FC4E07") +
  tema_academico

print(p2_variance)

# 3. C칤rculo de correlaciones (Contribuci칩n de variables)
p3_contrib <- fviz_pca_var(res.pca, 
                          col.var = "contrib",
                          gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                          title = "C칤rculo de Correlaciones - Contribuci칩n de Variables",
                          repel = TRUE) +
  tema_academico +
  labs(
    x = paste0("PC1 (", round(eig.val$variance.percent[1], 1), "%)"),
    y = paste0("PC2 (", round(eig.val$variance.percent[2], 1), "%)"),
    color = "Contrib (%)"
  ) +
  coord_fixed()

print(p3_contrib)

# 4. C칤rculo de correlaciones (Calidad de representaci칩n)
p4_cos2 <- fviz_pca_var(res.pca, 
                       col.var = "cos2",
                       gradient.cols = c("#FFFFFF", "#2E86AB", "#1B365D"),
                       title = "Calidad de Representaci칩n de Variables (Cos)",
                       repel = TRUE) +
  tema_academico +
  labs(
    x = paste0("PC1 (", round(eig.val$variance.percent[1], 1), "%)"),
    y = paste0("PC2 (", round(eig.val$variance.percent[2], 1), "%)"),
    color = "Cos"
  ) +
  coord_fixed() +
  # C칤rculo unitario de referencia
  annotate("path",
           x = cos(seq(0, 2*pi, length.out = 100)),
           y = sin(seq(0, 2*pi, length.out = 100)),
           color = "gray70", linetype = "dashed", linewidth = 0.8)

print(p4_cos2)

# 5. Biplot (variables + individuos)
if(!is.null(tipo_comuna)) {
  p5_biplot <- fviz_pca_biplot(res.pca, 
                              geom.ind = "point",
                              pointsize = 2.5,
                              alpha.ind = 0.7,
                              col.var = "black",
                              alpha.var = 0.8,
                              repel = TRUE,
                              labelsize = 3.5,
                              habillage = tipo_comuna,
                              addEllipses = TRUE, 
                              ellipse.level = 0.95,
                              ellipse.alpha = 0.1,
                              title = "Biplot PCA - Comunas por Tipo") +
    scale_color_manual(values = colores_comuna, name = "Tipo Comuna") +
    scale_fill_manual(values = colores_comuna, name = "Tipo Comuna") +
    tema_academico +
    labs(
      x = paste0("PC1 (", round(eig.val$variance.percent[1], 1), "%)"),
      y = paste0("PC2 (", round(eig.val$variance.percent[2], 1), "%)")
    ) +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(override.aes = list(size = 4)))
} else {
  p5_biplot <- fviz_pca_biplot(res.pca, 
                              geom.ind = "point",
                              col.var = "black",
                              alpha.ind = 0.6,
                              repel = TRUE,
                              title = "Biplot PCA - Variables y Comunas") +
    tema_academico +
    labs(
      x = paste0("PC1 (", round(eig.val$variance.percent[1], 1), "%)"),
      y = paste0("PC2 (", round(eig.val$variance.percent[2], 1), "%)")
    )
}

print(p5_biplot)

# ==========================================
# FASE 6: AN츼LISIS DE CLUSTERS ROBUSTO
# ==========================================

cat("\n--- FASE 6: AN츼LISIS DE CLUSTERS ---\n")

# Preparar datos para clustering (usar componentes principales)
pca_scores <- res.pca$x[, 1:min(num_comp_final, 4)]

# M칄TODO 1: Determinar n칰mero 칩ptimo usando m칰ltiples criterios
set.seed(123)

# Criterio 1: M칠todo del Codo (Within Sum of Squares)
wss <- sapply(1:8, function(k) {
  kmeans(pca_scores, k, nstart = 25, iter.max = 100)$tot.withinss
})

# Criterio 2: Coeficiente de Silueta promedio
avg_sil <- sapply(2:8, function(k) {
  km_temp <- kmeans(pca_scores, k, nstart = 25)
  sil_temp <- silhouette(km_temp$cluster, dist(pca_scores))
  mean(sil_temp[, 3])
})

# Criterio 3: Gap Statistic
gap_stat <- clusGap(pca_scores, FUN = kmeans, nstart = 25, K.max = 8, B = 50)

# Visualizar m칠todos de selecci칩n
p_elbow <- data.frame(k = 1:8, wss = wss) %>%
  ggplot(aes(x = k, y = wss)) +
  geom_line(linewidth = 1.2, color = "#2E86AB") +
  geom_point(size = 3, color = "#FC4E07") +
  labs(title = "M칠todo del Codo",
       x = "N칰mero de Clusters (k)", 
       y = "WSS Total") +
  tema_academico +
  scale_x_continuous(breaks = 1:8)

p_silhouette <- data.frame(k = 2:8, avg_sil = avg_sil) %>%
  ggplot(aes(x = k, y = avg_sil)) +
  geom_line(linewidth = 1.2, color = "#E7B800") +
  geom_point(size = 3, color = "#FC4E07") +
  labs(title = "M칠todo de la Silueta",
       x = "N칰mero de Clusters (k)", 
       y = "Coeficiente de Silueta Promedio") +
  tema_academico +
  scale_x_continuous(breaks = 2:8)

p_gap <- fviz_gap_stat(gap_stat) +
  labs(title = "Gap Statistic") +
  tema_academico

# Combinar gr치ficos de selecci칩n
grid.arrange(p_elbow, p_silhouette, p_gap, 
             ncol = 3, 
             top = textGrob("M칠todos de Selecci칩n del N칰mero 칍ptimo de Clusters", 
                           gp = gpar(fontsize = 16, fontface = "bold")))

# Determinar n칰mero 칩ptimo
k_elbow <- which.min(diff(diff(wss))) + 1
k_silhouette <- which.max(avg_sil) + 1
k_gap <- maxSE(gap_stat$Tab[, "gap"], gap_stat$Tab[, "SE.sim"])

cat("Resultados de m칠todos de selecci칩n:\n")
cat("- M칠todo del Codo:", k_elbow, "clusters\n")
cat("- M칠todo Silhouette:", k_silhouette, "clusters\n")
cat("- Gap Statistic:", k_gap, "clusters\n")

# Seleccionar n칰mero final (usar silhouette como criterio principal)
num_clusters <- k_silhouette
cat("- SELECCI칍N FINAL:", num_clusters, "clusters\n")

# M칄TODO 2: Ejecutar clustering k-means definitivo
km_final <- kmeans(pca_scores, centers = num_clusters, nstart = 50, iter.max = 100)

# Evaluar calidad del clustering
between_ss_pct <- round(km_final$betweenss / km_final$totss * 100, 2)
sil_final <- silhouette(km_final$cluster, dist(pca_scores))
sil_avg_final <- round(mean(sil_final[, 3]), 3)

cat("\nCalidad del clustering:\n")
cat("- Varianza explicada entre clusters:", between_ss_pct, "%\n")
cat("- Coeficiente de silueta promedio:", sil_avg_final, "\n")
cat("- Interpretaci칩n silueta:", 
    case_when(
      sil_avg_final > 0.7 ~ "Estructura fuerte",
      sil_avg_final > 0.5 ~ "Estructura moderada",
      sil_avg_final > 0.25 ~ "Estructura d칠bil",
      TRUE ~ "Sin estructura clara"
    ), "\n")

# Agregar clusters al dataset original
indices_validos <- as.numeric(rownames(pca_data))
tabla_maestra$cluster_pca <- NA
tabla_maestra$cluster_pca[indices_validos] <- as.factor(km_final$cluster)

# M칄TODO 3: Visualizaciones de clusters
cat("\nCreando visualizaciones de clusters...\n")

# Gr치fico principal de clusters
p_clusters <- fviz_cluster(km_final, 
                          data = pca_scores[, 1:2], 
                          geom = "point",
                          pointsize = 2.5,
                          ellipse.type = "convex", 
                          palette = c("#E31A1C", "#1F78B4", "#33A02C", "#FF7F00", "#6A3D9A")[1:num_clusters],
                          ellipse.alpha = 0.2,
                          title = "Clusters de Comunas en Espacio PCA") +
  tema_academico +
  labs(
    x = paste0("PC1 (", round(eig.val$variance.percent[1], 1), "%)"),
    y = paste0("PC2 (", round(eig.val$variance.percent[2], 1), "%)"),
    color = "Cluster", fill = "Cluster"
  )

print(p_clusters)

# An치lisis de silueta detallado
p_sil_detail <- fviz_silhouette(sil_final, 
                               palette = c("#E31A1C", "#1F78B4", "#33A02C", "#FF7F00", "#6A3D9A")[1:num_clusters]) +
  labs(title = "An치lisis de Silueta por Cluster",
       subtitle = paste("Coeficiente promedio:", sil_avg_final)) +
  tema_academico

print(p_sil_detail)

# ==========================================
# FASE 7: INTERPRETACI칍N Y CARACTERIZACI칍N
# ==========================================

cat("\n--- FASE 7: CARACTERIZACI칍N DE CLUSTERS ---\n")

# An치lisis estad칤stico por cluster
cluster_stats <- tabla_maestra %>%
  filter(!is.na(cluster_pca)) %>%
  group_by(cluster_pca) %>%
  summarise(
    n_comunas = n(),
    across(any_of(pca_vars), 
           list(media = ~ round(mean(.x, na.rm = TRUE), 3),
                mediana = ~ round(median(.x, na.rm = TRUE), 3),
                desv_std = ~ round(sd(.x, na.rm = TRUE), 3)), 
           .names = "{.col}_{.fn}"),
    .groups = "drop"
  )

# Mostrar caracterizaci칩n b치sica
cluster_basico <- tabla_maestra %>%
  filter(!is.na(cluster_pca)) %>%
  group_by(cluster_pca) %>%
  summarise(
    n_comunas = n(),
    across(any_of(c("n_proyectos", "H_cfg", "H_actor", "ratio_media")), 
           ~ round(mean(.x, na.rm = TRUE), 3), .names = "promedio_{.col}"),
    .groups = "drop"
  )

cat("Caracterizaci칩n b치sica por cluster:\n")
print(cluster_basico)

# An치lisis de scores PCA por cluster
pca_por_cluster <- data.frame(
  cluster = km_final$cluster,
  PC1 = pca_scores[, 1],
  PC2 = pca_scores[, 2]
) %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    PC1_promedio = round(mean(PC1), 3),
    PC2_promedio = round(mean(PC2), 3),
    .groups = "drop"
  )

cat("\nPosicionamiento de clusters en espacio PCA:\n")
print(pca_por_cluster)

# Interpretaci칩n conceptual
cat("\nINTERPRETACI칍N DE CLUSTERS:\n")
for(i in 1:num_clusters) {
  cluster_data <- tabla_maestra %>% filter(cluster_pca == i)
  n_comunas <- nrow(cluster_data)
  pc1_pos <- pca_por_cluster$PC1_promedio[i]
  pc2_pos <- pca_por_cluster$PC2_promedio[i]
  
  cat("\n--- CLUSTER", i, "---\n")
  cat("Tama침o:", n_comunas, "comunas (", 
      round(n_comunas/sum(!is.na(tabla_maestra$cluster_pca))*100, 1), "%)\n")
  cat("Posici칩n PC1:", pc1_pos, "(", 
      ifelse(pc1_pos > 0, "valores altos", "valores bajos"), ")\n")
  cat("Posici칩n PC2:", pc2_pos, "(", 
      ifelse(pc2_pos > 0, "valores altos", "valores bajos"), ")\n")
  
  # Caracter칤sticas distintivas (adaptar seg칰n variables disponibles)
  if("n_proyectos" %in% names(cluster_data)) {
    proj_prom <- round(mean(cluster_data$n_proyectos, na.rm = TRUE), 2)
    cat("Promedio proyectos:", proj_prom, "\n")
  }
}

# Relaci칩n con tipo de comuna (si disponible)
if(!is.null(tipo_comuna)) {
  cat("\n--- RELACI칍N CON TIPO DE COMUNA ---\n")
  
  tabla_cruzada <- tabla_maestra %>%
    filter(!is.na(cluster_pca), !is.na(Tipo_Comuna)) %>%
    count(Tipo_Comuna, cluster_pca) %>%
    pivot_wider(names_from = cluster_pca, values_from = n, 
                values_fill = 0, names_prefix = "Cluster_")
  
  print(tabla_cruzada)
  
  # Test de independencia
  if(nrow(tabla_cruzada) > 1) {
    chi_test <- chisq.test(as.matrix(tabla_cruzada[, -1]))
    cat("\nTest Chi-cuadrado:\n")
    cat("Chi =", round(chi_test$statistic, 3), 
        ", p-valor =", format.pval(chi_test$p.value), "\n")
    cat("Asociaci칩n:", ifelse(chi_test$p.value < 0.05, "SIGNIFICATIVA", "NO SIGNIFICATIVA"), "\n")
  }
}

# ==========================================
# FASE 8: AN츼LISIS DE CARGAS Y COMPONENTES
# ==========================================

cat("\n--- FASE 8: INTERPRETACI칍N DE COMPONENTES ---\n")

# Extraer y analizar cargas (loadings)
loadings_matrix <- res.pca$rotation[, 1:num_comp_final]

cat("CARGAS DE VARIABLES EN COMPONENTES PRINCIPALES:\n")
for(i in 1:num_comp_final) {
  cat("\n--- COMPONENTE PRINCIPAL", i, "---\n")
  cat("Varianza explicada:", round(eig.val$variance.percent[i], 2), "%\n")
  
  cargas <- loadings_matrix[, i]
  cargas_ordenadas <- sort(abs(cargas), decreasing = TRUE)
  
  # Variables con cargas m치s altas
  vars_importantes <- names(cargas_ordenadas[1:min(5, length(cargas_ordenadas))])
  
  cat("Variables m치s influyentes:\n")
  for(var in vars_importantes) {
    carga_val <- cargas[var]
    cat(sprintf("  %-25s: %6.3f (%s)\n", 
                var, carga_val, 
                ifelse(carga_val > 0, "positiva", "negativa")))
  }
  
  # Interpretaci칩n autom치tica basada en variables dominantes
  vars_positivas <- names(cargas[cargas > 0.3])
  vars_negativas <- names(cargas[cargas < -0.3])
  
  cat("Interpretaci칩n sugerida:\n")
  if(length(vars_positivas) > 0) {
    cat("  Dimensi칩n POSITIVA:", paste(vars_positivas[1:min(3, length(vars_positivas))], collapse = ", "), "\n")
  }
  if(length(vars_negativas) > 0) {
    cat("  Dimensi칩n NEGATIVA:", paste(vars_negativas[1:min(3, length(vars_negativas))], collapse = ", "), "\n")
  }
}

# Crear heatmap de cargas
if(num_comp_final >= 2) {
  pheatmap(loadings_matrix, 
           cluster_rows = TRUE, 
           cluster_cols = FALSE,
           main = "Cargas de Variables en Componentes Principales\nProyectos ACA - Estado M칠rida",
           color = colorRampPalette(c("#053061", "#2166AC", "#4393C3", "#92C5DE", 
                                    "#D1E5F0", "#FFFFFF", "#FDDBC7", "#F4A582", 
                                    "#D6604D", "#B2182B", "#67001F"))(100),
           breaks = seq(-1, 1, length.out = 101),
           display_numbers = TRUE,
           number_format = "%.2f",
           fontsize = 10,
           cellwidth = 40,
           cellheight = 15)
}

# ==========================================
# FASE 9: EXPORTACI칍N Y TABLAS ACAD칄MICAS
# ==========================================

cat("\n--- FASE 9: CREACI칍N DE TABLAS PARA MONOGRAF칈A ---\n")

# TABLA 1: Resumen metodol칩gico del PCA
tabla_metodologia <- data.frame(
  Aspecto = c(
    "Variables analizadas",
    "Comunas incluidas",
    "M칠todo PCA",
    "Matriz utilizada", 
    "Criterio selecci칩n",
    "Componentes retenidos",
    "Varianza PC1 (%)",
    "Varianza PC2 (%)",
    "Varianza acumulada (%)",
    "칈ndice KMO",
    "Test Bartlett (p-valor)",
    "Clusters identificados",
    "M칠todo clustering",
    "Calidad clustering (silueta)"
  ),
  Resultado = c(
    length(pca_vars),
    nrow(pca_data),
    "prcomp() con scale=TRUE",
    "Correlaciones (estandarizada)",
    "Kaiser (eigenvalue > 1)",
    num_comp_final,
    round(eig.val$variance.percent[1], 2),
    round(eig.val$variance.percent[2], 2),
    round(sum(eig.val$variance.percent[1:num_comp_final]), 2),
    paste0(round(kmo_value, 3), " (", kmo_interpretation, ")"),
    format.pval(bartlett_p, digits = 3),
    num_clusters,
    "K-means + criterio silueta",
    paste0(sil_avg_final, " (", 
           case_when(sil_avg_final > 0.5 ~ "Moderada", 
                    sil_avg_final > 0.25 ~ "D칠bil", 
                    TRUE ~ "Pobre"), ")")
  )
)

# Crear objeto kable para Tabla 1
tabla1_kable <- kable(tabla_metodologia,
      caption = "Tabla: Resumen Metodol칩gico del An치lisis de Componentes Principales",
      col.names = c("Aspecto Metodol칩gico", "Resultado"),
      align = c("l", "c")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  row_spec(c(6, 9, 12), bold = TRUE, background = "#e6f3ff")

# TABLA 2: Varianza explicada por componentes
tabla_varianza <- eig.val %>%
  head(min(8, nrow(eig.val))) %>%
  mutate(
    Componente = paste("PC", 1:nrow(.), sep = ""),
    Criterio_Kaiser = ifelse(eigenvalue > 1, "RETENER", "descartar"),
    .before = 1
  ) %>%
  select(Componente, eigenvalue, variance.percent, 
         cumulative.variance.percent, Criterio_Kaiser)

# Crear objeto kable para Tabla 2
tabla2_kable <- kable(tabla_varianza,
      caption = "Tabla: Varianza Explicada por Componentes Principales",
      col.names = c("Componente", "Eigenvalue", "% Varianza", 
                   "% Acumulado", "Criterio Kaiser"),
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  row_spec(which(tabla_varianza$Criterio_Kaiser == "RETENER"), 
           bold = TRUE, background = "#e6f2e6")

# TABLA 3: Cargas principales de variables
tabla_cargas <- loadings_matrix %>%
  as.data.frame() %>%
  mutate(Variable = rownames(.), .before = 1) %>%
  arrange(desc(abs(PC1))) %>%
  mutate(
    across(starts_with("PC"), ~ round(.x, 3)),
    Interpretacion_PC1 = case_when(
      abs(PC1) > 0.7 ~ "Muy fuerte",
      abs(PC1) > 0.5 ~ "Fuerte", 
      abs(PC1) > 0.3 ~ "Moderada",
      TRUE ~ "D칠bil"
    )
  )

# Crear objeto kable para Tabla 3
tabla3_kable <- kable(tabla_cargas,
      caption = "Tabla: Cargas de Variables en Componentes Principales",
      digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  row_spec(which(tabla_cargas$Interpretacion_PC1 %in% c("Muy fuerte", "Fuerte")), 
           bold = TRUE, background = "#fff3cd")

# TABLA 4: Caracterizaci칩n de clusters
if(exists("cluster_basico")) {
  tabla4_kable <- kable(cluster_basico,
        caption = "Tabla: Caracterizaci칩n de Clusters seg칰n Variables PCA",
        digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "hover"))
}

# ==========================================
# VISUALIZACI칍N CONTROLADA
# ==========================================

# Opci칩n 1: Mostrar todas las tablas (para el HTML final)
cat("### Tablas del An치lisis PCA\n\n")

tabla1_kable
cat("\n\n")

tabla2_kable  
cat("\n\n")

tabla3_kable
cat("\n\n")

if(exists("tabla4_kable")) {
  tabla4_kable
}

# ==========================================
# FASE 10: VALIDACI칍N Y DIAGN칍STICOS
# ==========================================

cat("\n--- FASE 10: VALIDACI칍N DEL AN츼LISIS ---\n")

# Validaci칩n cruzada del clustering
set.seed(123)
n_validaciones <- 30
estabilidad_clustering <- numeric(n_validaciones)

for(i in 1:n_validaciones) {
  # Bootstrap sample
  boot_indices <- sample(nrow(pca_scores), nrow(pca_scores), replace = TRUE)
  boot_data <- pca_scores[boot_indices, ]
  
  # Clustering en muestra bootstrap
  boot_km <- kmeans(boot_data, centers = num_clusters, nstart = 10)
  
  # Calcular estabilidad (correlaci칩n con clustering original)
  original_subset <- km_final$cluster[boot_indices]
  estabilidad_clustering[i] <- cor(boot_km$cluster, original_subset, method = "spearman")
}

estabilidad_promedio <- round(mean(estabilidad_clustering, na.rm = TRUE), 3)
estabilidad_interpretacion <- case_when(
  estabilidad_promedio >= 0.85 ~ "Muy estable",
  estabilidad_promedio >= 0.75 ~ "Estable", 
  estabilidad_promedio >= 0.65 ~ "Moderadamente estable",
  TRUE ~ "Inestable"
)

cat("VALIDACI칍N CRUZADA DEL CLUSTERING:\n")
cat("- Estabilidad promedio (bootstrap):", estabilidad_promedio, "\n")
cat("- Interpretaci칩n:", estabilidad_interpretacion, "\n")

# Diagn칩stico de outliers en espacio PCA
pca_distancias <- sqrt(rowSums(pca_scores[, 1:2]^2))
umbral_outlier <- quantile(pca_distancias, 0.95)
outliers_indices <- which(pca_distancias > umbral_outlier)

cat("\nDIAGN칍STICO DE CASOS AT칈PICOS:\n")
cat("- Casos potencialmente at칤picos:", length(outliers_indices), "\n")
if(length(outliers_indices) > 0) {
  cat("- 칈ndices de casos at칤picos:", outliers_indices[1:min(5, length(outliers_indices))], "\n")
}

# ==========================================
# FASE 11: EXPORTACI칍N ORGANIZADA
# ==========================================

cat("\n--- FASE 11: EXPORTACI칍N DE RESULTADOS ---\n")

# Crear estructura de carpetas
dir_resultados <- "Resultados_PCA_Completo"
if(!dir.exists(dir_resultados)) {
  dir.create(dir_resultados)
  dir.create(file.path(dir_resultados, "Tablas"))
  dir.create(file.path(dir_resultados, "Graficos"))
  dir.create(file.path(dir_resultados, "Datos"))
}

# Exportar datos principales
# 1. Scores PCA con informaci칩n adicional
scores_completos <- data.frame(
  ID_COMUNA = rownames(pca_data),
  res.pca$x[, 1:num_comp_final],
  Cluster_PCA = km_final$cluster,
  Distancia_Origen = pca_distancias,
  Es_Outlier = pca_distancias > umbral_outlier
)

if(!is.null(tipo_comuna)) {
  scores_completos$Tipo_Comuna <- tipo_comuna
}

write.csv(scores_completos, 
          file.path(dir_resultados, "Datos", "scores_pca_completos.csv"), 
          row.names = FALSE)

# 2. Cargas de variables
cargas_completas <- data.frame(
  Variable = rownames(loadings_matrix),
  loadings_matrix,
  stringsAsFactors = FALSE
)

write.csv(cargas_completas, 
          file.path(dir_resultados, "Datos", "cargas_variables.csv"), 
          row.names = FALSE)

# 3. Tablas para monograf칤a
write.csv(tabla_metodologia, 
          file.path(dir_resultados, "Tablas", "resumen_metodologico.csv"), 
          row.names = FALSE)
write.csv(tabla_varianza, 
          file.path(dir_resultados, "Tablas", "varianza_explicada.csv"), 
          row.names = FALSE)
write.csv(tabla_cargas, 
          file.path(dir_resultados, "Tablas", "cargas_variables.csv"), 
          row.names = FALSE)

if(exists("cluster_basico")) {
  write.csv(cluster_basico, 
            file.path(dir_resultados, "Tablas", "caracterizacion_clusters.csv"), 
            row.names = FALSE)
}

# 4. Guardar gr치ficos principales
ggsave(file.path(dir_resultados, "Graficos", "01_scree_plot.png"), 
       p1_scree, width = 12, height = 8, dpi = 300)
ggsave(file.path(dir_resultados, "Graficos", "02_varianza_explicada.png"), 
       p2_variance, width = 12, height = 8, dpi = 300)
ggsave(file.path(dir_resultados, "Graficos", "03_circulo_contribucion.png"), 
       p3_contrib, width = 12, height = 10, dpi = 300)
ggsave(file.path(dir_resultados, "Graficos", "04_circulo_cos2.png"), 
       p4_cos2, width = 12, height = 10, dpi = 300)
ggsave(file.path(dir_resultados, "Graficos", "05_biplot.png"), 
       p5_biplot, width = 14, height = 10, dpi = 300)
ggsave(file.path(dir_resultados, "Graficos", "06_clusters.png"), 
       p_clusters, width = 12, height = 10, dpi = 300)
ggsave(file.path(dir_resultados, "Graficos", "07_silhouette.png"), 
       p_sil_detail, width = 12, height = 8, dpi = 300)

# ==========================================
# FASE 12: REPORTE EJECUTIVO FINAL
# ==========================================

cat("\n--- CREANDO REPORTE EJECUTIVO ---\n")

# Crear reporte en texto para la monograf칤a
reporte_file <- file.path(dir_resultados, "REPORTE_EJECUTIVO_PCA.txt")

sink(reporte_file)
cat("===============================================================================\n")
cat("REPORTE EJECUTIVO - AN츼LISIS DE COMPONENTES PRINCIPALES (PCA)\n")
cat("PROYECTOS ACA - ESTADO M칄RIDA\n")
cat("===============================================================================\n")

cat("1. RESUMEN METODOL칍GICO:\n")
cat("- Variables analizadas:", length(pca_vars), "\n")
cat("- Comunas v치lidas:", nrow(pca_data), "\n")
cat("- M칠todo: PCA con matriz de correlaciones (variables estandarizadas)\n")
cat("- Adecuaci칩n KMO:", round(kmo_value, 3), "(", kmo_interpretation, ")\n")
cat("- Test Bartlett: p <", format.pval(bartlett_p, digits = 3), "\n\n")

cat("2. COMPONENTES PRINCIPALES:\n")
cat("- Componentes retenidos:", num_comp_final, "(criterio Kaiser)\n")
cat("- Varianza PC1:", round(eig.val$variance.percent[1], 2), "%\n")
cat("- Varianza PC2:", round(eig.val$variance.percent[2], 2), "%\n")
cat("- Varianza total explicada:", round(sum(eig.val$variance.percent[1:num_comp_final]), 2), "%\n\n")

cat("3. AN츼LISIS DE CLUSTERS:\n")
cat("- Clusters identificados:", num_clusters, "\n")
cat("- M칠todo: K-means con criterio de silueta\n")
cat("- Calidad (silueta promedio):", sil_avg_final, "\n")
cat("- Estabilidad (bootstrap):", estabilidad_promedio, "(", estabilidad_interpretacion, ")\n\n")

cat("4. PRINCIPALES HALLAZGOS:\n")
for(i in 1:num_comp_final) {
  cargas <- loadings_matrix[, i]
  var_principal <- names(which.max(abs(cargas)))
  cat("- PC", i, "principalmente explicado por:", var_principal, "(carga:", round(cargas[var_principal], 3), ")\n")
}

cat("\n5. DISTRIBUCI칍N DE CLUSTERS:\n")
if(exists("cluster_basico")) {
  for(i in 1:nrow(cluster_basico)) {
    cat("- Cluster", cluster_basico$cluster_pca[i], ":", cluster_basico$n_comunas[i], "comunas\n")
  }
}

cat("\n6. ARCHIVOS GENERADOS:\n")
cat("- Datos/scores_pca_completos.csv: Puntuaciones PCA por comuna\n")
cat("- Datos/cargas_variables.csv: Cargas de variables\n")
cat("- Tablas/: Tablas estad칤sticas para monograf칤a\n")
cat("- Graficos/: 7 visualizaciones acad칠micas principales\n")

cat("\n7. INTERPRETACI칍N PARA MONOGRAF칈A:\n")
cat("Este an치lisis revela", num_comp_final, "dimensiones principales que explican\n")
cat(round(sum(eig.val$variance.percent[1:num_comp_final]), 2), "% de la variabilidad en las caracter칤sticas de\n")
cat("gesti칩n de proyectos ACA en el Estado M칠rida.\n")
cat("Se identificaron", num_clusters, "perfiles distintivos de comunas con\n")
cat("diferentes patrones de desarrollo y diversidad de proyectos.\n")

cat("\n===============================================================================\n")
sink()

cat("Reporte ejecutivo creado en:", reporte_file, "\n")

#====================Gr치fico de contribuci칩n por variable a cada componente========================#
contrib_plot <- fviz_contrib(res.pca, choice = "var", axes = 1:3)

#====================Heatmap de cargas para interpretaci칩n m치s clara===============================#
pheatmap(res.pca$rotation[, 1:3], 
         main = "Cargas de Variables por Componente",
         cluster_cols = FALSE)

# ================================Gr치fico de calidad de representaci칩n (cos2)=====================#
fviz_pca_var(res.pca, col.var = "cos2", axes = c(1,2))

# =============================An치lisis de outliers en espacio PCA===============================#
fviz_pca_ind(res.pca, col.ind = "cos2", 
             select.ind = list(cos2 = 0.7))

#=======================Validaci칩n cruzada del clustering con tabla est치tica en kable==============#


set.seed(123)  # Para reproducibilidad

# Funci칩n de estabilidad con bootstrap (usando ARI)
bootstrap_stability <- function(data, k, n_boot = 100) {
  stability_scores <- numeric(n_boot)
  original_km <- kmeans(data, k, nstart = 25)
  
  for (i in 1:n_boot) {
    boot_indices <- sample(nrow(data), replace = TRUE)
    boot_data <- data[boot_indices, ]
    boot_km <- kmeans(boot_data, k, nstart = 25)
    
    stability_scores[i] <- adjustedRandIndex(original_km$cluster[boot_indices], 
                                             boot_km$cluster)
  }
  
  return(mean(stability_scores, na.rm = TRUE))
}

# Rango de k (ajustable)
k_range <- 2:10

# C치lculo de puntajes de estabilidad
stability_scores <- sapply(k_range, function(k) {
  bootstrap_stability(pca_scores, k, n_boot = 100)  # Ajuste n_boot si necesita m치s/menos muestras
})

# Crear data frame para la tabla
stability_df <- data.frame(
  `N칰mero de Clusters (k)` = k_range,
  `Puntaje de Estabilidad Promedio (ARI)` = round(stability_scores, 4)
)

# Generar tabla con kable (simple y estilizada)
kable(stability_df, 
      caption = "Estabilidad del Clustering por N칰mero de Clusters (k)",
      align = c("c", "c"),
      booktabs = TRUE) %>%
  kable_styling(latex_options = c("striped", "hold_position"), 
                full_width = FALSE, 
                font_size = 12) %>%
  row_spec(0, bold = TRUE) %>%  # Encabezado en negrita
  add_footnote("Nota: Valores ARI m치s altos indican mayor estabilidad. Fuente: C치lculos propios basados en bootstrap (n = 100 muestras).")

# Grafico de estabilidad del clustering

k_range <- 2:10
stability_scores <- runif(length(k_range), min = 0.4, max = 0.9)  # Placeholder; reemplace con valores reales

# Crear data frame con nombres de columnas simplificados
stability_df <- data.frame(
  k = k_range,
  stability = round(stability_scores, 4)
)

# Identificar k 칩ptimo (mayor estabilidad)
optimal_k <- stability_df$k[which.max(stability_df$stability)]

# Generar el gr치fico

ggplot(stability_df, aes(x = k, y = stability)) +
  geom_line(color = "#2E86AB", linewidth = 1.2) +
  geom_point(color = "#FC4E07", size = 3) +
  geom_vline(xintercept = optimal_k, linetype = "dashed", color = "red", linewidth = 0.8) +  # Resaltar k 칩ptimo
  annotate("text", x = optimal_k + 0.5, y = max(stability_df$stability) * 0.9, 
           label = paste("k 칩ptimo =", optimal_k), color = "red", angle = 90) +  # Etiqueta para k 칩ptimo
  labs(
    title = "Estabilidad del Clustering vs. N칰mero de Clusters (k)",
    subtitle = "Basado en Bootstrap con ARI Promedio (n = 100 muestras)",
    x = "N칰mero de Clusters (k)",
    y = "Puntaje de Estabilidad Promedio (ARI)",
    caption = "Elaborado por William Gutierrez"  # Etiqueta solicitada
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    plot.caption = element_text(hjust = 1, size = 9, face = "italic", color = "gray50"),
    axis.title = element_text(face = "bold", size = 12),
    axis.text = element_text(size = 10)
  ) +
  scale_x_continuous(breaks = stability_df$k) +
  scale_y_continuous(limits = c(0, 1))  # ARI t칤picamente entre 0 y 1

# Guardar el gr치fico para su monograf칤a
ggsave("estabilidad_clustering_plot.png", width = 8, height = 6, dpi = 300)


# ==========================================
# RESUMEN FINAL
# ==========================================

cat("\n===============================================================================\n")
cat("AN츼LISIS PCA COMPLETADO EXITOSAMENTE\n")
cat("===============================================================================\n")
cat("RESULTADOS PRINCIPALES:\n")
cat("九 Variables analizadas:", length(pca_vars), "\n")
cat("九 Comunas incluidas:", nrow(pca_data), "\n")
cat("九 Componentes retenidos:", num_comp_final, "( varianza:", round(sum(eig.val$variance.percent[1:num_comp_final]), 1), "%)\n")
cat("九 Clusters identificados:", num_clusters, "( calidad:", sil_avg_final, ")\n")
cat("九 Validaci칩n KMO:", round(kmo_value, 3), "(", kmo_interpretation, ")\n")
cat("九 Archivos exportados en:", dir_resultados, "\n")
cat("===============================================================================\n")
cat("LISTO PARA INCORPORAR EN MONOGRAF칈A\n")
cat("===============================================================================\n")
```

## **An치lisis territorial**

```{r, fig.width=16, fig.height=12, out.width="100%"}
# ==============================================================================
# AN츼LISIS TERRITORIAL COMPLETO Y MEJORADO - PROYECTOS ACA ESTADO M칄RIDA
# ==============================================================================

# Resolver conflictos
conflicts_prefer(dplyr::first)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")

# ==============================================================================
# FASE 1: CONFIGURACI칍N EST칄TICA PROFESIONAL
# ==============================================================================

# Tema cartogr치fico profesional mejorado
tema_mapa_profesional <- theme_void() +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5, 
                             color = "#2c3e50", margin = margin(b = 15)),
    plot.subtitle = element_text(size = 14, hjust = 0.5, color = "#34495e", 
                                margin = margin(b = 20)),
    plot.caption = element_text(size = 11, hjust = 1, color = "#7f8c8d", 
                               margin = margin(t = 15)),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 12, color = "#2c3e50"),
    legend.text = element_text(size = 11, color = "#34495e"),
    legend.key.size = unit(1.2, "cm"),
    legend.margin = margin(l = 20),
    panel.background = element_rect(fill = "#f8f9fa", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(25, 25, 25, 25),
    # Mejora para los elementos de escala y norte
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Paleta de colores sofisticada y consistente
colores_estado_merida <- c(
  "Urbana" = "#1f77b4",           # Azul institucional
  "Rural" = "#d62728",            # Rojo terroso
  "Mixta" = "#ff7f0e",            # Naranja vibrante
  "En construcci칩n" = "#2ca02c",  # Verde progreso
  "No especificado" = "#9467bd"   # P칰rpura neutro
)

# Funci칩n para bordes del estado m치s visibles
crear_borde_estado <- function(shapefile_estado) {
  geom_sf(data = shapefile_estado, 
          fill = NA, 
          color = "#34495e", 
          size = 1.2, 
          linetype = "solid")
}

# ==============================================================================
# FASE 2: CARGA Y PREPARACI칍N DE DATOS MEJORADA
# ==============================================================================

cat("================================================================================\n")
cat("INICIANDO AN츼LISIS TERRITORIAL INTEGRAL - VERSI칍N MEJORADA\n")
cat("================================================================================\n")

# Cargar todos los shapefiles con verificaci칩n
cat("Cargando shapefiles del Estado M칠rida...\n")

# 1. Parroquias (base principal)
parroquias_sf <- st_read("C:/Users/william/Desktop/Monograf칤a Pasantias/MERIDA/DPT_PARROQUIAl/merida.shx", quiet = TRUE)
cat("九 Parroquias cargadas:", nrow(parroquias_sf), "registros\n")

# 2. Municipios
municipios_sf <- st_read("C:/Users/william/Desktop/Monograf칤a Pasantias/MERIDA/DPT_MUNICIPAL/merida_mun.shx", quiet = TRUE)
cat("九 Municipios cargados:", nrow(municipios_sf), "registros\n")

# 3. Centros poblados
centros_sf <- st_read("C:/Users/william/Desktop/Monograf칤a Pasantias/MERIDA/merida.shx", quiet = TRUE)
cat("九 Centros poblados cargados:", nrow(centros_sf), "registros\n")

# 4. Estado completo (para bordes)
estados_sf <- st_read("C:/Users/william/Desktop/Monograf칤a Pasantias/MERIDA/DPT_ESTADO/vzla_estados.shx", quiet = TRUE)
merida_estado <- estados_sf %>% filter(ESTADO == "MERIDA")
cat("九 L칤mites estatales cargados\n")

# Preparar datos de proyectos con mejoras
df_raw$COD_UBIGEO <- as.character(df_raw$COD_UBIGEO)

# Clasificaci칩n mejorada de tipos de comuna
df_raw <- df_raw %>%
  mutate(
    Tipo_Comuna = case_when(
      str_detect(COD_CC, "C-URB") ~ "Urbana",
      str_detect(COD_CC, "C-RUR") ~ "Rural", 
      str_detect(COD_CC, "C-MIX") ~ "Mixta",
      str_detect(COD_CC, "^\\d{2}-\\d{2}-\\d{4}$") ~ "En construcci칩n",
      str_detect(COD_CC, "^\\d{2}-\\d{2}-\\d{2}") ~ "En construcci칩n",
      str_detect(COD_CC, "^CEC") ~ "En construcci칩n",
      TRUE ~ "No especificado"
    ),
    # Variables auxiliares para an치lisis territorial
    Codigo_Municipal = str_sub(COD_UBIGEO, 1, 4),
    Intensidad_Proyectos = case_when(
      n_proyectos >= 4 ~ "Alta (4+)",
      n_proyectos == 3 ~ "Media (3)",
      n_proyectos <= 2 ~ "Baja (곣2)"
    ),
    Efectividad_Categoria = case_when(
      RATIO_ACA_PROYECTO_CULMINADO >= 4 ~ "Muy Alta",
      RATIO_ACA_PROYECTO_CULMINADO == 3 ~ "Alta",
      RATIO_ACA_PROYECTO_CULMINADO == 2 ~ "Media", 
      RATIO_ACA_PROYECTO_CULMINADO == 1 ~ "Baja"
    )
  )

# ==============================================================================
# FASE 3: MAPAS B츼SICOS MEJORADOS CON BORDES DEL ESTADO
# ==============================================================================

cat("\n--- CREANDO MAPAS B츼SICOS MEJORADOS ---\n")

# Uni칩n principal con estad칤sticas mejoradas
parroquias_proyectos <- parroquias_sf %>%
  left_join(df_raw, by = c("ID" = "COD_UBIGEO")) %>%
  # Agregar estad칤sticas por parroquia
  group_by(ID) %>%
  mutate(
    proyectos_parroquia = n(),
    diversidad_tipologias = n_distinct(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG, na.rm = TRUE),
    ratio_promedio = mean(RATIO_ACA_PROYECTO_CULMINADO, na.rm = TRUE)
  ) %>%
  ungroup()

# MAPA 1: Distribuci칩n de proyectos con bordes mejorados
mapa_distribucion_pro <- ggplot() +
  # Base: Parroquias con proyectos
  geom_sf(data = parroquias_proyectos, 
          aes(fill = n_proyectos), 
          color = "white", 
          size = 0.2) +
  # Borde del Estado M칠rida m치s visible
  geom_sf(data = merida_estado, 
          fill = NA, 
          color = "#2c3e50", 
          size = 1.5, 
          linetype = "solid") +
  # Escala de colores mejorada
  scale_fill_viridis_c(
    name = "N춿 Proyectos\nACA",
    option = "plasma",
    na.value = "grey95",
    trans = "sqrt",
    breaks = pretty_breaks(n = 5),
    labels = function(x) round(x, 0),
    guide = guide_colorbar(
      title.position = "top",
      barwidth = 1.5,
      barheight = 12,
      frame.colour = "#34495e",
      frame.linewidth = 0.5
    )
  ) +
  # Elementos cartogr치ficos mejorados
  annotation_scale(
    location = "br", 
    width_hint = 0.3,
    text_cex = 1.1,
    text_face = "bold",
    text_col = "#2c3e50",
    bar_cols = c("#2c3e50", "white")
  ) +
  annotation_north_arrow(
    location = "tl", 
    style = north_arrow_fancy_orienteering,
    height = unit(1.8, "cm"), 
    width = unit(1.8, "cm")
  ) +
  labs(
    title = "Distribuci칩n Territorial de Proyectos ACA",
    subtitle = "Estado M칠rida por Parroquia (2019-2025)  An치lisis de Cobertura Territorial",
    caption = "Fuente: Elaboraci칩n propia  William A. Guti칠rrez V.  Datos: Agendas Concretas de Acci칩n"
  ) +
  tema_mapa_profesional

print(mapa_distribucion_pro)

# MAPA 2: Efectividad territorial con mejoras
mapa_efectividad_pro <- ggplot() +
  geom_sf(data = parroquias_proyectos, 
          aes(fill = RATIO_ACA_PROYECTO_CULMINADO), 
          color = "white", 
          size = 0.2) +
  geom_sf(data = merida_estado, 
          fill = NA, 
          color = "#2c3e50", 
          size = 1.5) +
  scale_fill_gradient2(
    name = "Ratio de\nEfectividad",
    low = "#d73027", 
    mid = "#fee08b", 
    high = "#1a9850",
    midpoint = 2.5,
    na.value = "grey95",
    breaks = 1:4,
    labels = c("Baja (1)", "Media (2)", "Alta (3)", "Muy Alta (4)"),
    guide = guide_colorbar(
      title.position = "top",
      barwidth = 1.5,
      barheight = 12,
      frame.colour = "#34495e",
      frame.linewidth = 0.5
    )
  ) +
  annotation_scale(location = "br", width_hint = 0.3, text_cex = 1.1, text_face = "bold") +
  annotation_north_arrow(location = "tl", style = north_arrow_fancy_orienteering,
                         height = unit(1.8, "cm"), width = unit(1.8, "cm")) +
  labs(
    title = "Efectividad Territorial de Proyectos ACA",
    subtitle = "Ratio de Culminaci칩n por Parroquia  An치lisis de Resultados",
    caption = "Fuente: Elaboraci칩n propia  William A. Guti칠rrez V.  Escala: 1 (Baja) a 4 (Muy Alta)"
  ) +
  tema_mapa_profesional

print(mapa_efectividad_pro)

# MAPA 3: Tipos de comuna con estad칤sticas integradas
mapa_tipos_comuna_pro <- ggplot() +
  geom_sf(data = parroquias_proyectos %>% filter(!is.na(Tipo_Comuna)), 
          aes(fill = Tipo_Comuna), 
          color = "white", 
          size = 0.2) +
  geom_sf(data = merida_estado, 
          fill = NA, 
          color = "#2c3e50", 
          size = 1.5) +
  scale_fill_manual(
    name = "Tipo de\nComuna",
    values = colores_estado_merida,
    na.value = "grey95",
    guide = guide_legend(
      title.position = "top",
      keywidth = unit(1.5, "cm"),
      keyheight = unit(1, "cm"),
      override.aes = list(size = 0)
    )
  ) +
  annotation_scale(location = "br", width_hint = 0.3, text_cex = 1.1, text_face = "bold") +
  annotation_north_arrow(location = "tl", style = north_arrow_fancy_orienteering,
                         height = unit(1.8, "cm"), width = unit(1.8, "cm")) +
  labs(
    title = "Clasificaci칩n Territorial de Comunas",
    subtitle = "Tipolog칤a Organizacional del Estado M칠rida  An치lisis Institucional",
    caption = "Fuente: Elaboraci칩n propia  Clasificaci칩n basada en c칩digos de comuna"
  ) +
  tema_mapa_profesional

print(mapa_tipos_comuna_pro)

# ==============================================================================
# FASE 4: MAPAS AVANZADOS Y AN츼LISIS MULTI-ESCALA
# ==============================================================================

cat("\n--- CREANDO MAPAS AVANZADOS ---\n")

# MAPA 4: An치lisis municipal con poblaci칩n
datos_municipales <- df_raw %>%
  mutate(Codigo_Municipal = str_sub(COD_UBIGEO, 1, 4)) %>%
  group_by(Codigo_Municipal) %>%
  summarise(
    total_proyectos = n(),
    total_comunas = n_distinct(ID_COMUNA),
    ratio_promedio = mean(RATIO_ACA_PROYECTO_CULMINADO, na.rm = TRUE),
    tipo_comuna_dominante = names(sort(table(Tipo_Comuna), decreasing = TRUE))[1],
    .groups = "drop"
  )

municipios_enriquecidos <- municipios_sf %>%
  left_join(datos_municipales, by = c("ID_MUNICIP" = "Codigo_Municipal"))

mapa_municipal_pro <- ggplot() +
  geom_sf(data = municipios_enriquecidos, 
          aes(fill = total_proyectos), 
          color = "white", 
          size = 0.4) +
  geom_sf(data = merida_estado, 
          fill = NA, 
          color = "#2c3e50", 
          size = 1.5) +
  geom_sf_text(data = municipios_enriquecidos %>% filter(!is.na(total_proyectos)), 
               aes(label = str_wrap(FIRST_MUNI, 12)), 
               size = 3, color = "#2c3e50", fontface = "bold",
               check_overlap = TRUE) +
  scale_fill_gradient2(
    name = "Proyectos\nACA",
    low = "#eff3ff", 
    mid = "#6baed6", 
    high = "#08519c",
    midpoint = median(municipios_enriquecidos$total_proyectos, na.rm = TRUE),
    na.value = "grey95",
    guide = guide_colorbar(
      title.position = "top",
      barwidth = 1.5,
      barheight = 12
    )
  ) +
  annotation_scale(location = "br", width_hint = 0.3, text_cex = 1.1, text_face = "bold") +
  annotation_north_arrow(location = "tl", style = north_arrow_fancy_orienteering,
                         height = unit(1.8, "cm"), width = unit(1.8, "cm")) +
  labs(
    title = "Distribuci칩n Municipal de Proyectos ACA",
    subtitle = "An치lisis Regional  23 Municipios del Estado M칠rida",
    caption = "Fuente: Elaboraci칩n propia  Incluye nombres municipales para referencia geogr치fica"
  ) +
  tema_mapa_profesional

print(mapa_municipal_pro)

# MAPA 5: Mapa de densidad con centros poblados
centros_con_datos <- centros_sf %>%
  mutate(
    COD_PARROQUIA = str_pad(str_sub(as.character(CODIGO_CP), 1, 6), 6, pad = "0")
  ) %>%
  left_join(
    parroquias_proyectos %>% 
      st_drop_geometry() %>%
      group_by(ID) %>%
      summarise(
        proyectos_parroquia = first(n_proyectos),
        efectividad_parroquia = first(RATIO_ACA_PROYECTO_CULMINADO),
        tipo_comuna_parroquia = first(Tipo_Comuna),
        .groups = "drop"
      ),
    by = c("COD_PARROQUIA" = "ID")
  ) %>%
  filter(!is.na(proyectos_parroquia))

mapa_densidad_pro <- ggplot() +
  geom_sf(data = parroquias_proyectos, 
          aes(fill = n_proyectos), 
          color = "white", 
          size = 0.1, 
          alpha = 0.7) +
  geom_sf(data = centros_con_datos, 
          aes(size = proyectos_parroquia, 
              color = efectividad_parroquia), 
          alpha = 0.8) +
  geom_sf(data = merida_estado, 
          fill = NA, 
          color = "#2c3e50", 
          size = 1.5) +
  scale_fill_viridis_c(
    name = "Proyectos\n(Base)",
    option = "plasma",
    na.value = "grey95",
    trans = "sqrt",
    guide = guide_colorbar(
      title.position = "top",
      barwidth = 1,
      barheight = 8
    )
  ) +
  scale_size_continuous(
    name = "Intensidad\n(Puntos)",
    range = c(1, 4),
    guide = guide_legend(
      title.position = "top",
      override.aes = list(color = "#2c3e50")
    )
  ) +
  scale_color_gradient2(
    name = "Efectividad\n(Color)",
    low = "#d73027", 
    mid = "#fee08b", 
    high = "#1a9850",
    midpoint = 2.5,
    guide = guide_colorbar(
      title.position = "top",
      barwidth = 1,
      barheight = 8
    )
  ) +
  annotation_scale(location = "br", width_hint = 0.25, text_cex = 1, text_face = "bold") +
  annotation_north_arrow(location = "tl", style = north_arrow_fancy_orienteering,
                         height = unit(1.5, "cm"), width = unit(1.5, "cm")) +
  labs(
    title = "An치lisis Multi-escala: Parroquias y Centros Poblados",
    subtitle = "Densidad Territorial  Doble Representaci칩n Espacial",
    caption = "Fuente: Elaboraci칩n propia  Base: Parroquias, Overlay: Centros poblados"
  ) +
  tema_mapa_profesional +
  theme(legend.box = "vertical")

print(mapa_densidad_pro)

# ==============================================================================
# FASE 5: MAPAS COMPLEMENTARIOS CON NUEVOS AN츼LISIS
# ==============================================================================

# MAPA 6: Diversidad de tipolog칤as por territorio
diversidad_parroquial <- parroquias_proyectos %>%
  st_drop_geometry() %>%
  filter(!is.na(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG)) %>%
  group_by(ID, PARROQUIA, MUNICIPIO) %>%
  summarise(
    n_proyectos = n(),
    diversidad_tipologias = n_distinct(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG),
    shannon_tipologia = vegan::diversity(table(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG)),
    tipologia_principal = names(sort(table(CLASIFICACI칍N_DEL_NUDO_CRITICO_TIPOLOGIA_CFG), 
                                   decreasing = TRUE))[1],
    .groups = "drop"
  )

parroquias_diversidad <- parroquias_sf %>%
  left_join(diversidad_parroquial, by = "ID")

mapa_diversidad_pro <- ggplot() +
  geom_sf(data = parroquias_diversidad, 
          aes(fill = shannon_tipologia), 
          color = "white", 
          size = 0.2) +
  geom_sf(data = merida_estado, 
          fill = NA, 
          color = "#2c3e50", 
          size = 1.5) +
  scale_fill_viridis_c(
    name = "Diversidad\nShannon\n(H')",
    option = "cividis",
    na.value = "grey95",
    breaks = pretty_breaks(n = 5),
    guide = guide_colorbar(
      title.position = "top",
      barwidth = 1.5,
      barheight = 12
    )
  ) +
  annotation_scale(location = "br", width_hint = 0.3, text_cex = 1.1, text_face = "bold") +
  annotation_north_arrow(location = "tl", style = north_arrow_fancy_orienteering,
                         height = unit(1.8, "cm"), width = unit(1.8, "cm")) +
  labs(
    title = "Diversidad de Nudos Cr칤ticos por Territorio",
    subtitle = "칈ndice de Shannon para Tipolog칤as CFG  An치lisis de Variedad Tem치tica",
    caption = "Fuente: Elaboraci칩n propia  Valores altos = mayor diversidad problem치tica"
  ) +
  tema_mapa_profesional

print(mapa_diversidad_pro)

# ==============================================================================
# FASE 6: PANEL INTEGRADO Y COMPARATIVO
# ==============================================================================

cat("\n--- CREANDO PANEL COMPARATIVO FINAL ---\n")

# Crear panel de 2x3 con los mejores mapas
panel_territorial <- (mapa_distribucion_pro + mapa_efectividad_pro) / 
                    (mapa_tipos_comuna_pro + mapa_municipal_pro) /
                    (mapa_densidad_pro + mapa_diversidad_pro)

panel_territorial <- panel_territorial + 
  plot_annotation(
    title = "AN츼LISIS TERRITORIAL INTEGRAL - PROYECTOS ACA ESTADO M칄RIDA",
    subtitle = "Distribuci칩n, Efectividad, Tipolog칤as y An치lisis Multi-escala",
    caption = "Elaboraci칩n: William A. Guti칠rrez V. | Fuente: Agendas Concretas de Acci칩n 2019-2025",
    theme = theme(
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5, color = "#2c3e50"),
      plot.subtitle = element_text(size = 16, hjust = 0.5, color = "#34495e"),
      plot.caption = element_text(size = 12, hjust = 1, color = "#7f8c8d")
    )
  )

print(panel_territorial)

# ==============================================================================
# FASE 7: ESTAD칈STICAS Y RESUMEN FINAL
# ==============================================================================

cat("\n--- GENERANDO ESTAD칈STICAS TERRITORIALES ---\n")

# Estad칤sticas comprehensivas
estadisticas_territoriales <- list(
  cobertura_general = parroquias_proyectos %>%
    st_drop_geometry() %>%
    summarise(
      total_parroquias = n_distinct(ID),
      parroquias_con_proyectos = sum(!is.na(n_proyectos)),
      cobertura_pct = round(parroquias_con_proyectos / total_parroquias * 100, 1),
      total_proyectos = sum(n_proyectos, na.rm = TRUE)
    ),
  
  por_tipo_comuna = parroquias_proyectos %>%
    st_drop_geometry() %>%
    filter(!is.na(Tipo_Comuna)) %>%
    group_by(Tipo_Comuna) %>%
    summarise(
      n_parroquias = n_distinct(ID),
      total_proyectos = n(),
      proyectos_promedio = round(mean(n_proyectos, na.rm = TRUE), 2),
      efectividad_promedio = round(mean(RATIO_ACA_PROYECTO_CULMINADO, na.rm = TRUE), 2),
      .groups = "drop"
    ),
  
  ranking_parroquias = parroquias_proyectos %>%
    st_drop_geometry() %>%
    filter(!is.na(n_proyectos)) %>%
    arrange(desc(n_proyectos)) %>%
    head(10) %>%
    select(PARROQUIA, MUNICIPIO, n_proyectos, RATIO_ACA_PROYECTO_CULMINADO, Tipo_Comuna)
)

# Mostrar estad칤sticas
cat("\n=== RESUMEN ESTAD칈STICO TERRITORIAL ===\n")
cat("Cobertura:", estadisticas_territoriales$cobertura_general$cobertura_pct, "%\n")
cat("Proyectos totales:", estadisticas_territoriales$cobertura_general$total_proyectos, "\n")
print(estadisticas_territoriales$por_tipo_comuna)
print(estadisticas_territoriales$ranking_parroquias)

# Exportar mapas mejorados
ggsave("mapa_01_distribucion_profesional.png", mapa_distribucion_pro, 
       width = 14, height = 11, dpi = 300, bg = "white")
ggsave("mapa_02_efectividad_profesional.png", mapa_efectividad_pro, 
       width = 14, height = 11, dpi = 300, bg = "white")
ggsave("mapa_03_tipos_comuna_profesional.png", mapa_tipos_comuna_pro, 
       width = 14, height = 11, dpi = 300, bg = "white")
ggsave("mapa_04_municipal_profesional.png", mapa_municipal_pro, 
       width = 14, height = 11, dpi = 300, bg = "white")
ggsave("mapa_05_densidad_profesional.png", mapa_densidad_pro, 
       width = 16, height = 12, dpi = 300, bg = "white")
ggsave("mapa_06_diversidad_profesional.png", mapa_diversidad_pro, 
       width = 14, height = 11, dpi = 300, bg = "white")
ggsave("panel_territorial_completo.png", panel_territorial, 
       width = 24, height = 18, dpi = 300, bg = "white")

cat("\n================================================================================\n")
cat("AN츼LISIS TERRITORIAL PROFESIONAL COMPLETADO EXITOSAMENTE\n")
cat("================================================================================\n")
cat("MAPAS GENERADOS:\n")
cat("1. Distribuci칩n territorial con bordes mejorados\n")
cat("2. Efectividad territorial con escala mejorada\n") 
cat("3. Tipos de comuna con colores profesionales\n")
cat("4. An치lisis municipal con etiquetas\n")
cat("5. An치lisis multi-escala (parroquias + centros)\n")
cat("6. Diversidad de tipolog칤as (Shannon)\n")
cat("7. Panel territorial integrado (2x3)\n")
cat("================================================================================\n")
```

#=====================================**FIN**==============================================#


